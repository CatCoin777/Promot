[
    {
        "instance_id": "astropy__astropy-11693",
        "structure_problem": {
            "problemSummary": "The 'WCS.all_world2pix' function fails to converge when plotting an image with a WCS projection containing non-linear distortions.",
            "context": "The issue arises when attempting to plot an image with a WCS projection that includes non-linear distortions. The function `all_world2pix` does not converge to the requested accuracy, leading to an exception being raised.",
            "stepsToReproduce": [
                "Create a WCS object with naxis=2.",
                "Define the SIP distortion parameters (a, b, ap, bp, crpix).",
                "Assign the SIP distortion parameters to the WCS object.",
                "Plot the image using matplotlib with the WCS projection."
            ],
            "expectedResults": "The plot should successfully render without any convergence issues.",
            "actualResults": "The plot fails with a 'NoConvergence' error, indicating that the solution is diverging after 20 iterations.",
            "supplementaryImages": [
                "None provided"
            ],
            "additionalNotes": "Adding the `quiet=True` parameter to the `all_world2pix` call at line 326 of `astropy/wcs/wcsapi/fitswcs.py` allows the plot to be generated, but it is considered a workaround rather than a proper solution."
        }
    },
    {
        "instance_id": "astropy__astropy-13838",
        "structure_problem": {
            "problemSummary": "An error occurs when printing a table with events containing null array data.",
            "context": "The issue arises when attempting to print a table using the `QTable` function with a list of dictionaries. Each dictionary contains integer values and some fields set the length for array values. Printing the table works fine when it includes events with data in the array fields, but when it only includes events with null array data, an `IndexError` is thrown.",
            "stepsToReproduce": [
                "Create a list of dictionaries with integer values and array values set to null.",
                "Use the `QTable` function to print the table with the list of dictionaries as the 'rows' attribute.",
                "Attempt to print the table."
            ],
            "expectedResults": "The table should print correctly even when it contains only events with null array data.",
            "actualResults": "An `IndexError` is thrown when attempting to print the table with only events containing null array data.",
            "supplementaryImages": [],
            "additionalNotes": "The error message indicates an issue with indexing out of bounds for axis 1 with size 0."
        }
    },
    {
        "instance_id": "astropy__astropy-14295",
        "structure_problem": {
            "problemSummary": "The presence of SIP keywords leads to ignored PV keywords in the astropy wcs parsing process.",
            "context": "The user is working on updating the fits header for a telescope, aiming to represent distortions in SIP convention with a 'CAR' projection. The issue arises when SIP coefficients are present in the header and/or '-SIP' is added to CTYPEia keywords, causing astropy to treat PV keywords as redundant.",
            "stepsToReproduce": [
                "Initialize the header with SIP and PV keywords.",
                "Parse the header using astropy.wcs.WCS.",
                "Plot the graticule.",
                "Remove the PV keywords and run again."
            ],
            "expectedResults": "The image should be centered at ra=120 and dec=29 with lines of constant ra and dec looking like the expected grid.",
            "actualResults": "The astropy wcs grid/solution does not change whether PV keywords are kept or removed, and the resulting grid is different from the expected one.",
            "supplementaryImages": [
                "Image 1: Grid generated using wcslib.",
                "Image 2: Grid generated using astropy wcs with PV keywords.",
                "Image 3: Grid generated using astropy wcs without PV keywords."
            ],
            "additionalNotes": "The astropy wcs grid can be recreated in wcslib by removing the PV keywords. The issue affects the functionality of astropy wcs when dealing with SIP distortions."
        }
    },
    {
        "instance_id": "astropy__astropy-8292",
        "structure_problem": {
            "problemSummary": "The implementation of the `littleh` equivalency in Astropy seems to be incorrect, as it does not correctly convert distances from `Mpc/h` to `Mpc` when `h` is specified.",
            "context": "The `littleh` equivalency is used for converting between physical and dimensionless distances in astrophysics. It is expected to work correctly with different values of `h`.",
            "stepsToReproduce": [
                "Set `distance = 100 * (u.Mpc/u.littleh)`",
                "Use `distance.to(u.Mpc, u.with_H0(H0_70))` to convert the distance to `Mpc` assuming `h=0.7`"
            ],
            "expectedResults": "The expected result should be a distance of 140 Mpc, as 100 Mpc/h with `h=0.7` should be equivalent to 140 Mpc.",
            "actualResults": "The actual result is 67.74 Mpc, which is incorrect.",
            "supplementaryImages": [
                "The figure provided in the issue description demonstrates the incorrect conversion result."
            ],
            "additionalNotes": "This issue affects the accuracy of conversions using the `littleh` equivalency, which could lead to incorrect astronomical distance calculations."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-13908",
        "structure_problem": {
            "problemSummary": "Minor ticklabels are missing at positions of major ticks in Matplotlib when using a specific configuration of major and minor locators.",
            "context": "The issue occurs when setting the major locator to `mdates.DayLocator()` and the minor locator to `mdates.HourLocator((0,6,12,18))`. The expected outcome is to have ticklabels for hours throughout the day, as seen in Matplotlib versions 3.0.2 or below.",
            "stepsToReproduce": [
                "Import necessary libraries: numpy, matplotlib.dates, matplotlib.pyplot.",
                "Create an array of dates `t` from '2018-11-03' to '2018-11-06'.",
                "Create an array of random values `x` corresponding to `t`.",
                "Create a figure and axis.",
                "Plot the data.",
                "Set the major locator to `mdates.DayLocator()`.",
                "Set the major formatter to `mdates.DateFormatter('\n%a')`.",
                "Set the minor locator to `mdates.HourLocator((0,6,12,18))`.",
                "Set the minor formatter to `mdates.DateFormatter('%H:%M')`.",
                "Display the plot."
            ],
            "expectedResults": "Ticklabels for hours (00:00, 06:00, 12:00, 18:00) should be present throughout the plot, as seen in versions 3.0.2 or below.",
            "actualResults": "Ticklabels for hours are missing at positions of major ticks.",
            "supplementaryImages": [
                "Figure showing the issue with missing minor ticklabels.",
                "Figure showing the expected outcome with ticklabels for hours present."
            ],
            "additionalNotes": "The issue is reported to occur in the current master branch of Matplotlib."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-13980",
        "structure_problem": {
            "problemSummary": "The polar plot's default bottom y_limit is not zero, which causes confusion for users unfamiliar with the concept of a polar plot where r=0 is not at the very center point of the plot.",
            "context": "The issue arises when plotting a set of data on a polar plot using Matplotlib version 3.0.2. The user expects the bottom y_limit to be zero, but it is not, leading to a plot with a hole around the origin.",
            "stepsToReproduce": [
                "Create a set of random data points for theta and r.",
                "Plot the data on a polar plot using Matplotlib.",
                "Observe that the bottom y_limit is not zero, resulting in a plot with a hole around the origin."
            ],
            "expectedResults": "The bottom y_limit of the polar plot should be zero.",
            "actualResults": "The bottom y_limit of the polar plot is not zero, resulting in a plot with a hole around the origin.",
            "supplementaryImages": [
                "Two polar plots are provided: one with the expected bottom y_limit set to zero (left) and one with the default bottom y_limit (right)."
            ],
            "additionalNotes": "The issue has been observed on Windows 10 and Ubuntu Linux operating systems, using JupyterLab 0.35.4 and Python versions 3.7 and 3.6."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-13983",
        "structure_problem": {
            "problemSummary": "Removing a shared axis in matplotlib prevents the remaining axes from using unit-provided formatters, leading to incorrect tick formatting.",
            "context": "When using matplotlib's subplots with shared axes, removing one subplot impacts the formatting of the remaining subplot.",
            "stepsToReproduce": [
                "Create a figure with two subplots sharing the x-axis.",
                "Remove one subplot using `axs[1].remove()`.",
                "Plot data on the remaining subplot.",
                "Display the figure."
            ],
            "expectedResults": "The remaining subplot should retain the correct tick formatter and locator.",
            "actualResults": "The remaining subplot loses the correct tick formatter and locator.",
            "supplementaryImages": [
                "A graph with incorrect tick formatting due to the removal of a shared axis."
            ],
            "additionalNotes": "Using `fig.delaxes(axs[1])` instead of `axs[1].remove()` does not exhibit this issue."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-13984",
        "structure_problem": {
            "problemSummary": "Tick mark color cannot be set on Axes3D using the `ax.tick_params` method. The method only changes the color of tick labels, not the tick marks themselves.",
            "context": "According to a comment on StackOverflow, this functionality used to work as expected in version 1.3.1 of matplotlib.",
            "stepsToReproduce": [
                "Import necessary libraries and create a 3D plot using `Axes3D`.",
                "Set the color of the axes lines to red using `ax.w_xaxis.line.set_color('red')`, `ax.w_yaxis.line.set_color('red')`, and `ax.w_zaxis.line.set_color('red')`.",
                "Set the color of the axis labels to red using `ax.xaxis.label.set_color('red')`, `ax.yaxis.label.set_color('red')`, and `ax.zaxis.label.set_color('red')`.",
                "Try to set the color of the tick marks to red using `ax.tick_params(axis='x', colors='red')`, `ax.tick_params(axis='y', colors='red')`, and `ax.tick_params(axis='z', colors='red')`. This step is expected to fail."
            ],
            "expectedResults": "The tick marks on the x, y, and z axes should be red.",
            "actualResults": "The tick marks on the x, y, and z axes remain unchanged, only the tick labels are red.",
            "additionalNotes": "This issue has been discussed on StackOverflow with several proposed workarounds."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-14043",
        "structure_problem": {
            "problemSummary": "Bar plot error bars break when zorder is greater than 1.",
            "context": "The issue occurs when creating a bar plot with error bars and setting the zorder property to a value greater than 1.",
            "stepsToReproduce": [
                "Create a figure and an axis using `plt.subplots(1,1)`. ",
                "Define data lists for x, y, and yerr.",
                "Plot bars using `ax.bar` with different zorder values."
            ],
            "expectedResults": "The error bars should be correctly displayed for bars with zorder values greater than 1.",
            "actualResults": "The error bars are not correctly displayed for bars with zorder values greater than 1.",
            "supplementaryImages": [
                "The image provided shows bars with varying zorder values and the error bars are not correctly displayed for bars with zorder values greater than 1."
            ],
            "additionalNotes": "This issue is related to #1622."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-19763",
        "structure_problem": {
            "problemSummary": "Multicursor disappears when not moving on nbagg with useblit=False and burns CPU",
            "context": "The issue was noticed by @ipcoder in a GitHub issue. The problem occurs on the nbagg backend, where the multicursor disappears when the mouse is not moving. Additionally, adding the multicursor causes high CPU usage and constant kernel busy indicator flashing.",
            "stepsToReproduce": [
                "Install Matplotlib version 3.3.4.post2456+gfd23bb238 and Jupyter Notebook 6.2.0",
                "Run the provided code snippet that includes plotting two sine waves and creating a multicursor",
                "Observe that the multicursor disappears when the mouse is not moving on the nbagg backend",
                "Note the high CPU usage and constant kernel busy indicator flashing when the multicursor is displayed"
            ],
            "expectedResults": "Expected the multicursor to remain visible when the mouse is not moving and the CPU usage to be stable",
            "actualResults": "The multicursor disappears when the mouse is not moving and the CPU usage jumps with constant kernel busy indicator flashing",
            "supplementaryImages": [
                "Image of the plot without the multicursor",
                "Image of the plot with the multicursor"
            ],
            "additionalNotes": "This issue was observed on Ubuntu with Python version 3.9.1 and the nbagg backend. The problem does not occur on the qt backend."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-20470",
        "structure_problem": {
            "problemSummary": "Text label in matplotlib is not being displayed in the legend.",
            "context": "The user is plotting a line and adding text to the plot. Both the line and text have labels. The line's label appears in the legend, but the text's label does not.",
            "stepsToReproduce": [
                "Plot a line with a label.",
                "Add text to the plot with a label.",
                "Create a legend for the plot."
            ],
            "expectedResults": "The legend should include an entry for the text label.",
            "actualResults": "The legend does not include an entry for the text label.",
            "supplementaryImages": [
                "A plot showing a line and text, with a legend that includes only the line label."
            ],
            "additionalNotes": "Matplotlib version used is 3.3.3."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-20518",
        "structure_problem": {
            "problemSummary": "The PGF backend in Matplotlib ignores calls to `set_sketch_params()`, resulting in no influence on the resulting pgf or pdf file.",
            "context": "The issue was discovered when attempting to use the `set_sketch_params()` method to apply sketch effects to the plot, but the effects were not visible in the output files.",
            "stepsToReproduce": [
                "1. Import the necessary libraries (`matplotlib` and `matplotlib.pylab`).",
                "2. Configure the Matplotlib settings for the PGF backend.",
                "3. Create a figure and add a subplot.",
                "4. Plot some data using `ax.plot()`.",
                "5. Set sketch parameters using `ax.spines[\"bottom\"].set_sketch_params()`.",
                "6. Save the figure to pgf and pdf files using `fig.savefig()`."
            ],
            "expectedResults": "The sketch effect should be applied to the plot, visible in both the pgf and pdf output files.",
            "actualResults": "The sketch effect is not applied to the plot, and there is no difference between the output files with and without the sketch parameters.",
            "supplementaryImages": [
                "Image 1: The plot without sketch parameters.",
                "Image 2: The plot with sketch parameters set, but no visual change observed."
            ],
            "additionalNotes": "The user is working on a fix for this issue."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-20584",
        "structure_problem": {
            "problemSummary": "The user noticed that after plotting with `contourf` and manipulating the lines, the result became much coarser. Even a simple `lc.set_segments(lc.get_segments())` caused this effect.",
            "context": "The issue was encountered while trying to manipulate the lines after plotting with `contourf`.",
            "stepsToReproduce": [
                "Plot a contour with `contourf`.",
                "Retrieve the lines and manipulate them.",
                "Observe that the result becomes coarser."
            ],
            "expectedResults": "Expected that the manipulation would not affect the quality of the plot.",
            "actualResults": "The result became much coarser after manipulation.",
            "supplementaryImages": [
                "Comparison of default plot and plot after resetting segments."
            ],
            "additionalNotes": "This issue was observed with matplotlib version 3.4.2."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-20761",
        "structure_problem": {
            "problemSummary": "Subfigure position shifts lower on the y-axis when 'x' kwarg is used for supxlabel for that subfigure.",
            "context": "The issue occurs when using the 'x' kwarg for supxlabel in a subfigure that is nested in another subfigure. The subfigure's body shifts downward and covers the supxlabel.",
            "stepsToReproduce": [
                "Create a figure with subfigures using constrained_layout.",
                "Add axes to the subfigures and set titles.",
                "Use supxlabel with the 'x' kwarg on the subfigure.",
                "Observe the subfigure position shift downward."
            ],
            "expectedResults": "The subfigure position should not change, and the supxlabel should shift to the right.",
            "actualResults": "The subfigure position shifts downward on the y-axis and covers the supxlabel.",
            "supplementaryImages": [
                "A set of images showing the expected and actual outcomes."
            ],
            "additionalNotes": "The issue is observed on Windows 10 Pro with Matplotlib version 3.4.2 and Python version 3.9.5. The environment was installed using conda from the conda-forge channel."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-20826",
        "structure_problem": {
            "problemSummary": "When using shared axes in matplotlib, calling `ax.clear()` causes ticks and tick labels to be shown that should be hidden. This behavior is observed in matplotlib 3.4.2 but not in 3.4.1.",
            "context": "The issue is encountered when using shared axes with `plt.subplots(2, 2, sharex=True, sharey=True)` and clearing the axes before plotting. This is relevant for creating animations with FuncAnimation where the plotting function is complex and does not facilitate blitting.",
            "stepsToReproduce": [
                "Import numpy and matplotlib.pyplot.",
                "Create a figure with 2x2 subplots using `plt.subplots(2, 2, sharex=True, sharey=True)`.",
                "Generate data arrays for x and y using numpy.",
                "Iterate over the flattened axes and clear each subplot.",
                "Plot the data on each subplot and observe the tick labels and ticks."
            ],
            "expectedResults": "The tick labels should be hidden and there should be no ticks along the top and right side of each subplot.",
            "actualResults": "Tick labels that should be hidden are shown, and there are ticks along the top and right side of each subplot that are not part of the default plotting style.",
            "supplementaryImages": [
                "A plot produced with matplotlib 3.4.2 showing the incorrect tick labels and ticks.",
                "A plot produced with matplotlib 3.4.1 showing the expected behavior."
            ],
            "additionalNotes": "The issue is observed in the context of creating animations with FuncAnimation, where the plotting function is complex and does not facilitate blitting. The problem is specific to matplotlib 3.4.2 and not observed in 3.4.1. The operating system is Ubuntu 20.04, and matplotlib is installed via conda from conda-forge."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-21443",
        "structure_problem": {
            "problemSummary": "When setting axes position with `ax = plt.axes(position = [...])`, the position data is not being incorporated, causing the axes to overlap instead of being separate.",
            "context": "The code provided demonstrates the issue with two axes that are expected to be separate but overlap instead.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot as plt",
                "Create a figure",
                "Define two positions for the axes",
                "Create the first axis with the first position",
                "Plot a red line in the first axis",
                "Create the second axis with the second position",
                "Plot a blue dashed line in the second axis"
            ],
            "expectedResults": "Two separate axes with the specified positions.",
            "actualResults": "The two axes completely overlap.",
            "supplementaryImages": [
                "Two figures are provided, showing the expected and actual results."
            ],
            "additionalNotes": "Running the code with `ax1.set_axes(pos1)` and `ax2.set_axes(pos2)` results in separate axes, indicating that the issue lies with the initial axes creation method."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-21490",
        "structure_problem": {
            "problemSummary": "Line2D in Matplotlib does not copy its inputs, leading to potential side effects when inputs are modified in place.",
            "context": "Line2D currently does not copy its inputs if they are already arrays, which can lead to unintended changes in the drawn line when inputs are modified.",
            "stepsToReproduce": [
                "Create a Line2D object using an array of values.",
                "Modify the original array in place after creating the Line2D object.",
                "Observe the effect on the Line2D object, especially when a cache invalidation occurs."
            ],
            "expectedResults": "Modifying the input array after creating a Line2D object should not affect the Line2D object.",
            "actualResults": "Modifying the input array can affect the Line2D object, particularly when a cache invalidation is triggered.",
            "supplementaryImages": [
                "Images showing the original line and changes after in-place modifications."
            ],
            "additionalNotes": "AxesImage, which typically handles larger inputs, does copy its inputs, which avoids similar issues."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-21550",
        "structure_problem": {
            "problemSummary": "The display is not working well when swapping matplotlib-3.4.3 with matplotlib-3.5.0.dev2445+gb09aad279b, all the rest being strictly equal.",
            "context": "This issue was observed in Jupyter Lab with matplotlib-3.5.0.dev2445+gb09aad279b, whereas it worked fine with matplotlib-3.4.3. The problem might be related to a change in matplotlib's rendering or display functionality.",
            "stepsToReproduce": [
                "Update matplotlib to version 3.5.0.dev2445+gb09aad279b.",
                "Run the provided code snippet in Jupyter Lab."
            ],
            "expectedResults": "The code should display a graph or plot as expected in matplotlib-3.4.3.",
            "actualResults": "The display does not work well, which is a deviation from the expected behavior.",
            "supplementaryImages": [
                "Image 1: Shows an incomplete or incorrect display when using matplotlib-3.5.0.dev2445+gb09aad279b.",
                "Image 2: Shows the expected correct display when using matplotlib-3.4.3."
            ],
            "additionalNotes": "The operating system is Windows 10, and the issue was also bad with rc1, so it was tested with the latest master, thanks to the artifact generation. The code snippet provided is the one used to reproduce the issue."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-21568",
        "structure_problem": {
            "problemSummary": "The datetime axis spacing is unclear when using `usetex=True` in matplotlib version 3.4 compared to version 3.3.",
            "context": "The issue occurs when plotting data with a datetime axis using matplotlib.",
            "stepsToReproduce": [
                "Import the necessary libraries: matplotlib, matplotlib.pyplot, numpy, pandas.",
                "Set the `usetex` parameter to True in matplotlib.rcParams.",
                "Create a datetime range and a random dataset.",
                "Plot the data with a datetime axis.",
                "Save the plot as an image."
            ],
            "expectedResults": "The datetime axis spacing should be consistent between matplotlib versions 3.3 and 3.4.",
            "actualResults": "The datetime axis spacing is different between matplotlib versions 3.3 and 3.4.",
            "supplementaryImages": [
                "Comparison of datetime axis spacing between matplotlib versions 3.3 and 3.4."
            ],
            "additionalNotes": "The issue is observed with the conda installation of matplotlib version 3.4.3 on Windows."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-21617",
        "structure_problem": {
            "problemSummary": "Text labels and title are missing when a figure rendered with cartopy in polar projection is saved to an EPS file using matplotlib v3.4.3, but not with v3.3.4.",
            "context": "The issue was encountered after updating matplotlib to version 3.4.3. The code used to render the figure in a Jupyter notebook was working as expected, but the text labels and title were not appearing in the saved EPS file.",
            "stepsToReproduce": [
                "Install matplotlib v3.4.3 and cartopy v0.18.0 using conda.",
                "Run the provided code snippet to create a figure with polar projection.",
                "Save the figure to an EPS file using plt.savefig()."
            ],
            "expectedResults": "The EPS file should contain the text '>>> do you see me <<<'.",
            "actualResults": "The EPS file does not contain the text '>>> do you see me <<<'.",
            "supplementaryImages": [
                "Two images are provided, one showing the expected outcome with matplotlib v3.3.4 and the other showing the actual outcome with matplotlib v3.4.3."
            ],
            "additionalNotes": "The testing environment was set up using conda with specific versions of matplotlib and cartopy. The issue might be related to another bug (#20364)."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-22865",
        "structure_problem": {
            "problemSummary": "The edges at the extremities of a matplotlib colorbar with 'drawedges=True' and 'extend=both' are not visible.",
            "context": "This issue occurs when creating a colorbar with matplotlib's 'drawedges' option set to True, which is supposed to separate the colors in the colorbar with black lines. However, when the 'extend' parameter is set to 'both', the black lines at the extremities of the colorbar do not appear as expected.",
            "stepsToReproduce": [
                "1. Import necessary libraries: matplotlib, numpy.",
                "2. Define a color map and set bounds for the color bar.",
                "3. Create a color map and normalization object from the levels and colors.",
                "4. Set up a figure and a subplot.",
                "5. Create a colorbar with 'drawedges=True' and 'extend=both'.",
                "6. Adjust the subplot layout and display the plot."
            ],
            "expectedResults": "The colorbar should display black lines separating the colors, including at the extremities.",
            "actualResults": "The black lines at the extremities of the colorbar are not visible.",
            "supplementaryImages": [
                "The provided images show the expected result with visible black lines at the extremities and the actual result with missing black lines at the extremities."
            ],
            "additionalNotes": "This issue was observed using matplotlib version 3.5.1."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-22871",
        "structure_problem": {
            "problemSummary": "The ConciseDateFormatter does not show the year anywhere when plotting less than 12 months and January is not included in the x-axis.",
            "context": "This bug is different from bug #21670 (fixed in #21785).",
            "stepsToReproduce": [
                "Import matplotlib.pyplot and matplotlib.dates as mdates.",
                "Create a time array from datetime(2021,2,14,0,0,0) to 199 days later.",
                "Create a data array with values from -x^2/20000 for x in range(1,200).",
                "Plot the data against the time array.",
                "Use AutoDateLocator and ConciseDateFormatter for x-axis formatting.",
                "Set x-axis label and grid.",
                "Apply fig.autofmt_xdate()."
            ],
            "expectedResults": "The year '2021' should appear in the offset to the right of the x-axis.",
            "actualResults": "The year does not show up anywhere.",
            "supplementaryImages": [
                "A plot showing the temperature (Â°C) over time from March to September."
            ],
            "additionalNotes": "Using Spyder IDE v5.1.5, Windows 10, Matplotlib v3.4.3, Qt5Agg backend, Python v3.9.1, and conda installation."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-22931",
        "structure_problem": {
            "problemSummary": "Plotting code that previously worked no longer displays a line and throws an error due to changes in the matplotlib library.",
            "context": "The issue occurs after a specific commit (#22569) in the matplotlib library. The code fails on the commit but passes on the parent commit.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot as plt.",
                "Create a figure and axis using plt.subplots().",
                "Plot a line with a specific linestyle using ax.plot([0, 1], [0, 1], ls=(0, ())).",
                "Display the plot using plt.show()."
            ],
            "expectedResults": "The line should be displayed on the plot.",
            "actualResults": "No line is shown, and an error is thrown while drawing.",
            "supplementaryImages": [
                "A plot with a straight line from (0,0) to (1,1)."
            ],
            "additionalNotes": "The error message indicates that at least one value in the dash list must be positive. The code uses a linestyle with a dash pattern that may be considered invalid. The issue might be fixed by using a different linestyle or by raising a more informative error message."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-23047",
        "structure_problem": {
            "problemSummary": "Gaps and overlapping areas are observed between bins when creating a histogram from float16 data.",
            "context": "The issue arises because the lower precision of float16 causes inaccuracies in bin calculations.",
            "stepsToReproduce": [
                "Create an array of float16 values.",
                "Use `plt.hist(values, bins=100, alpha=0.5)` to generate a histogram."
            ],
            "expectedResults": "A histogram with bins calculated accurately without gaps or overlaps.",
            "actualResults": "A histogram showing gaps between certain bins and overlapping areas between neighboring bins (visible only when alpha < 1).",
            "supplementaryImages": [
                "Histogram with float16 data showing gaps and overlaps."
            ],
            "additionalNotes": "A possible solution involves calculating bin edges in float32 to improve precision. Using float32 directly for the data is another option but may not be feasible due to memory limitations."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-23111",
        "structure_problem": {
            "problemSummary": "When using imshow to display a numpy array filled with identical negative values, hovering the mouse over the displayed image throws math domain errors into the console and stops the value and coordinate under the mouse from being displayed in the top right.",
            "context": "This issue occurs with a specific configuration of Matplotlib, Python, and Jupyter versions, as well as the QtAgg backend. The errors do not occur if a single value in the array is different or if set_clim() is used.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot and numpy.",
                "Create a numpy array filled with identical negative values.",
                "Use plt.imshow() to display the array.",
                "Hover the mouse over the displayed image."
            ],
            "expectedResults": "The value area should be displayed correctly without any math domain errors.",
            "actualResults": "Hovering the mouse over the plot spews math domain errors into the console and stops the value and coordinate under the mouse from being displayed in the top right.",
            "supplementaryImages": [
                "An image of the error message."
            ],
            "additionalNotes": "The issue does not occur if a single value in the array is different or if set_clim() is used. The delta in cbook\\__init__.py, line 2228, in _g_sig_digits might be negative in this case."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-23412",
        "structure_problem": {
            "problemSummary": "The linestyle offset on a patch object using a dash tuple has no effect, causing the edge lines to overlap instead of adhering to the offset.",
            "context": "The issue occurs with both Rectangle and Ellipse patch objects in Matplotlib version 3.3.4 on OS/X with the MacOSX backend.",
            "stepsToReproduce": [
                "Create a figure and add a subplot.",
                "Add a patch object (Rectangle or Ellipse) with a specified linestyle and linewidth.",
                "Set the linestyle to a dash tuple with an offset.",
                "Display the plot."
            ],
            "expectedResults": "The edge lines of the patch object should have a proper offset as specified in the linestyle tuple.",
            "actualResults": "The edge lines of the patch object overlap, not adhering to the specified offset.",
            "supplementaryImages": [
                "An image showing the overlapping edge lines of a Rectangle patch object."
            ],
            "additionalNotes": "The issue has been reproduced in Ubuntu 18.04 VM running Matplotlib 3.5.0 with the agg backend. The expected outcome is demonstrated with Line2D objects."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24088",
        "structure_problem": {
            "problemSummary": "An error occurs when attempting to add a colorbar to a histogram plot using matplotlib 3.6.0.",
            "context": "The error message indicates that the system is unable to determine the Axes to steal space for the colorbar. This issue did not occur in matplotlib 3.5.1.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot and numpy.",
                "Generate random data.",
                "Create a histogram with the data.",
                "Iterate over the histogram bars and set their color using a colormap.",
                "Attempt to add a colorbar to the figure."
            ],
            "expectedResults": "The colorbar should be added to the histogram plot without any errors.",
            "actualResults": "ValueError: Unable to determine Axes to steal space for Colorbar.",
            "supplementaryImages": [
                "Two images showing the expected and actual outcomes of adding a colorbar to a histogram plot."
            ],
            "additionalNotes": "The issue affects macOS 12.6 with Python 3.10 and matplotlib 3.6.0 installed via pip."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24177",
        "structure_problem": {
            "problemSummary": "Histogram density axis does not auto-scale correctly when using histtype='step' in matplotlib.axes.Axes.hist function.",
            "context": "The user is plotting a histogram of data generated by numpy.save from a binary format using matplotlib. The issue arises when the histogram's density axis does not adjust to fit the whole histogram when setting density=True, especially if the data array is rescaled. This behavior is observed when histtype='step' is used, but not for other histtypes.",
            "stepsToReproduce": [
                "1. Generate random data using numpy.random.randn and scale it.",
                "2. Plot histograms using matplotlib.axes.Axes.hist with different histtypes ('bar' and 'step') and density=True.",
                "3. Observe the differences in the density axis scaling for the histograms."
            ],
            "expectedResults": "The density axis should auto-scale correctly for all histtypes, regardless of data scaling.",
            "actualResults": "The density axis does not auto-scale correctly when using histtype='step'.",
            "supplementaryImages": [
                "Histograms with histtype='bar' and 'step' for scaled data.",
                "Histograms with histtype='bar' and 'step' for unscaled data."
            ],
            "additionalNotes": "The issue can be tested and reproduced using the provided code and data from the user's GitHub repository. The problem is observed on OS/X with matplotlib version 3.6.0 and Python version 3.10.4."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24189",
        "structure_problem": {
            "problemSummary": "Error occurs when using width_ratios or height_ratios with a nested list mosaic in subplot_mosaic() unless all outer and inner mosaics have the same number of columns or rows.",
            "context": "The issue arises from recursive layout building, passing the same gridspec_kw to subgridspec() at each level of nesting.",
            "stepsToReproduce": [
                "Define a nested list mosaic with different numbers of columns.",
                "Call plt.subplot_mosaic() with the nested mosaic and width_ratios or height_ratios.",
                "Encounter a ValueError: 'Expected the given number of width ratios to match the number of columns of the grid'."
            ],
            "expectedResults": "The user expected to be able to specify width_ratios or height_ratios for the outer list or have a helpful error message explaining the limitation.",
            "actualResults": "An error message was received indicating that the number of width ratios did not match the number of columns of the grid.",
            "supplementaryImages": [
                "Images showing the layout of the nested mosaic."
            ],
            "additionalNotes": "The user suggests implementing this feature for nested list layouts or providing a clearer error message."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24570",
        "structure_problem": {
            "problemSummary": "The `align` parameter in `HPacker` for the `top` and `bottom` options appears to be reversed.",
            "context": "The issue arises when attempting to align elements vertically within a `HPacker` using the `align` parameter. The expected alignment does not match the actual result.",
            "stepsToReproduce": [
                "Import necessary modules from matplotlib and matplotlib.offsetbox.",
                "Create `DrawingArea` instances (`da1` and `da2`) and add `Rectangle` artists to them.",
                "Set the `align` parameter to 'bottom' for the `HPacker` instance.",
                "Pack the `DrawingArea` instances into a `HPacker` with padding and separation.",
                "Create a `TextArea` for the title and pack it with the `HPacker` into a `VPacker`.",
                "Create an `AnchoredOffsetbox` with the `VPacker` and add it to a figure with an axis."
            ],
            "expectedResults": "When `align='bottom'`, the elements should align at the bottom in a horizontal packer.",
            "actualResults": "The elements align at the top instead of the bottom when `align='bottom'`.",
            "supplementaryImages": [
                "A visualization of the expected outcome where elements align at the bottom.",
                "A visualization of the actual outcome where elements align at the top."
            ],
            "additionalNotes": "The issue was observed in Matplotlib version 3.6.2."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24691",
        "structure_problem": {
            "problemSummary": "Request to set facecolor and edgecolor alpha separately for patches in matplotlib.",
            "context": "The user wants to create diagrams with solid patch edges and semi-transparent fills. Currently, the alpha setting applies to the entire patch, so the user manually adjusts the color to achieve the desired effect.",
            "expectedResults": "The user expects to have separate control over the alpha values for the facecolor and edgecolor of patches.",
            "actualResults": "The current implementation requires manual adjustment of colors to achieve semi-transparent fills and solid edges.",
            "supplementaryImages": [
                "Diagram illustrating a patch with a solid edge and a semi-transparent fill."
            ],
            "additionalNotes": "The user suggests allowing alpha to take a (facecolor, fillcolor) tuple for patch methods, similar to the feature in imshow method."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24749",
        "structure_problem": {
            "problemSummary": "The user encountered an 'IndexError' when attempting to plot a contour with matplotlib, indicating that the tuple index is out of range.",
            "context": "The issue seems to occur when the `Z` parameter is passed as a keyword argument to the `contour` function in matplotlib.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot as plt.",
                "Call plt.contour with Z as a keyword argument, where Z is a 2D array."
            ],
            "expectedResults": "The contour plot should display without errors.",
            "actualResults": "An 'IndexError' is raised, indicating that the tuple index is out of range.",
            "supplementaryImages": [
                "A blank plot, presumably the result of the error.",
                "A contour plot that seems to have been generated successfully."
            ],
            "additionalNotes": "Matplotlib version is 3.6.2, operating system is OS/X, and Python version is 3.8.15."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24768",
        "structure_problem": {
            "problemSummary": "Conflict between `pcolormesh(rasterized=True)` and `set_rasterization_zorder()` in matplotlib resulting in an AttributeError.",
            "context": "The user is attempting to rasterize a color plot using both `pcolormesh(rasterized=True)` and `set_rasterization_zorder()` simultaneously, which according to the documentation, are not compatible.",
            "stepsToReproduce": [
                "Import necessary libraries and generate data.",
                "Create a color plot using `pcolormesh(rasterized=True)`.",
                "Set rasterization zorder using `set_rasterization_zorder()`.",
                "Save the figure."
            ],
            "expectedResults": "The figure should be rasterized successfully without any errors.",
            "actualResults": "An AttributeError is raised during the save process.",
            "supplementaryImages": [
                "The provided image shows the color plot with the error message and version information."
            ],
            "additionalNotes": "The bug is observed in version 3.5.1 and commit 2d18bba0ea0e9fb9ccab508fa0a60ffc5946771b, but not in version 3.1.2. The issue seems to be related to reentrance tracking in the MixedModeRenderer."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24849",
        "structure_problem": {
            "problemSummary": "The 'gapcolor' parameter is not supported for LineCollections in Matplotlib, causing an error when attempting to use it with plotting methods like vlines or hlines.",
            "context": "LineCollection in Matplotlib does not have 'get_gapcolor' or 'set_gapcolor' methods, leading to an error when 'gapcolor' is used in plotting methods that return LineCollections.",
            "stepsToReproduce": [
                "Create a figure and an axis using plt.subplots().",
                "Use ax.vlines() with 'gapcolor' set to a color value, e.g., 'orange'."
            ],
            "expectedResults": "The 'gapcolor' parameter should work with LineCollections, allowing for the specification of gap colors in plots.",
            "actualResults": "An AttributeError is raised, indicating that 'LineCollection.set()' got an unexpected keyword argument 'gapcolor'.",
            "additionalNotes": "A suggested fix involves adding 'set_color' and 'get_color' methods to LineCollection, similar to those found in other collection classes within Matplotlib."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24870",
        "structure_problem": {
            "problemSummary": "The user is looking for a feature to automatically detect boolean arrays passed to plt.contour() and default the levels to [0.5] for these arrays, as this makes sense for boolean inputs.",
            "context": "The user often uses plt.contour() with boolean 2D arrays and wants to avoid manually specifying the levels parameter each time. Without specifying levels=[.5], the default 8 levels result in all contour lines being drawn on top of each other, which is not ideal for boolean inputs.",
            "additionalNotes": "The user proposes that boolean inputs to plt.contour() should be automatically detected, and the default levels should be set to [0.5] in such cases. This is similar to the autodetection feature in imshow that auto-switches between 0-1 float RGBA arrays and 0-255 uint8 RGBA arrays when given a 3D array as input."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24971",
        "structure_problem": {
            "problemSummary": "When saving a figure with compressed layout for the second time, the compressed layout is not applied.",
            "context": "The issue occurs under specific circumstances involving the use of compressed layout, saving the figure twice with `bbox_inches='tight'`, and certain combinations of matplotlib settings.",
            "stepsToReproduce": [
                "Import matplotlib, matplotlib.pyplot, numpy, and set matplotlib.rcParams['figure.constrained_layout.use'] to True.",
                "Create a figure with a mosaic layout and apply compressed layout.",
                "Save the figure twice with `bbox_inches='tight'`."
            ],
            "expectedResults": "Both saved images should look like the first image with compressed layout applied.",
            "actualResults": "The second saved image does not apply the compressed layout, resulting in a different appearance.",
            "supplementaryImages": [
                "test1.png: Expected figure with compressed layout.",
                "test2.png: Figure where compressed layout is not applied the second time."
            ],
            "additionalNotes": "The issue can be resolved by not setting the rcParams for compressed layout, not using `bbox_inches='tight'` in savefig calls, or reverting the rcParams setting for the specific figure."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-25287",
        "structure_problem": {
            "problemSummary": "The exponent label color in matplotlib is affected by 'ytick.color' instead of 'ytick.labelcolor' when setting 'ytick.labelcolor' in styles or rcParams.",
            "context": "This issue occurs in matplotlib version 3.6.3. The exponent label color should be influenced by 'ytick.labelcolor', not 'ytick.color'.",
            "stepsToReproduce": [
                "Update matplotlib's rcParams with {'ytick.labelcolor': 'red'}",
                "Create a figure and add a subplot",
                "Plot a simple line with data points [1.01e9, 1.02e9, 1.03e9]"
            ],
            "expectedResults": "The exponent label should be colored red, matching 'ytick.labelcolor'.",
            "actualResults": "The exponent label is colored based on 'ytick.color' instead of 'ytick.labelcolor'.",
            "supplementaryImages": [
                "Images provided in the issue showing the incorrect exponent label color."
            ],
            "additionalNotes": "A patch is provided that seems to fix the issue for simple use cases."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-25334",
        "structure_problem": {
            "problemSummary": "The contour plot fails with an assertion when all input values are NaN.",
            "context": "This issue is triggered by a test-case in the xarray test suite and is not typically noticed in release builds of matplotlib due to disabled assertion checks.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot and numpy.",
                "Create a 2D array `x` with all elements as NaN.",
                "Call `plt.contour(x)`."
            ],
            "expectedResults": "The user expects to see an empty plot with or without warnings.",
            "actualResults": "The actual outcome is a failed assertion in the contour plotting function.",
            "supplementaryImages": [
                "An empty image placeholder indicating the absence of an expected contour plot."
            ],
            "additionalNotes": "The environment is described as Linux with matplotlib version 3.0.3, installed from source, and Python version 3.6."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-25340",
        "structure_problem": {
            "problemSummary": "The set_val() method of a range slider doesn't set the value correctly with values close to the minimal and maximal values of the range slider.",
            "context": "The issue is observed with values in the middle, but not when using the valinit parameter of the constructor.",
            "stepsToReproduce": [
                "Create a range slider with specified valmin and valmax.",
                "Use set_val() to set values close to the minimal and maximal values.",
                "Observe the actual values set by set_val()."
            ],
            "expectedResults": "The values set by set_val() should match the specified values.",
            "actualResults": "The values set by set_val() are incorrect when close to the minimal and maximal values.",
            "supplementaryImages": [
                "Images showing the correct and incorrect behavior of set_val() with different values."
            ],
            "additionalNotes": "The problem occurs on Manjaro with Python 3.10.9, Matplotlib 3.6.2, and the QtAgg backend. The issue also affects Windows 10 with Python 3.11.0, Matplotlib 3.6.2, and the TkAgg backend."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-25346",
        "structure_problem": {
            "problemSummary": "Constrained layout in Matplotlib does not provide enough space for long, wrapped titles.",
            "context": "This issue occurs when using Matplotlib version 3.7.0 and main with QtAgg backend on RHEL7.",
            "stepsToReproduce": [
                "Create a figure with a subplots grid using `plt.subplots()` with `layout='constrained'`.",
                "Set a long, wrapped title for the figure using `fig.suptitle()`.",
                "Set a long, wrapped title for an axis using `ax.set_title()`."
            ],
            "expectedResults": "The figure and axis titles should fit within the layout, with enough space allocated for them.",
            "actualResults": "The titles are cut off or overlap with other elements due to insufficient space.",
            "supplementaryImages": [
                "An image of the figure with the long, wrapped titles showing that they are not fitting properly."
            ],
            "additionalNotes": "Wrapping the titles with an explicit newline (\n) resolves the issue, indicating it is specific to the wrapping feature."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-25405",
        "structure_problem": {
            "problemSummary": "Logarithmic tick markers do not appear if the y-axis scales a sufficient range, with the `subs` keyword argument of `ticker.LogLocator` set to non-trivial values.",
            "context": "The issue occurs when the y-axis scales a specific range, causing the tick markers to not appear as expected.",
            "stepsToReproduce": [
                "1. Import necessary libraries: matplotlib.pyplot, matplotlib.ticker, numpy",
                "2. Create a `LogLocator` with `subs=(1, 2, 5)`",
                "3. Plot a semilogy graph with `x = np.arange(8)` and `plt.semilogy(x, 10 ** x)`",
                "4. Set the y-axis major and minor locators to the created `LogLocator`",
                "5. Display the plot"
            ],
            "expectedResults": "Tick markers should appear at the expected locations on the y-axis.",
            "actualResults": "Tick markers do not appear on the y-axis when the y-axis scales a specific range.",
            "supplementaryImages": [
                "Good Plot: A plot with y-axis ticks at the expected locations",
                "Bad Plot: A plot with no y-axis ticks"
            ],
            "additionalNotes": "The problem is isolated to `ticker.LogLocator.tick_values()`, which returns correct values in the first case but `np.array([])` in the second case."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-25499",
        "structure_problem": {
            "problemSummary": "Setting bbox_inches to a Bbox in fig.savefig resizes the colorbar",
            "context": "When using matplotlib, setting bbox_inches to a specified Bbox in fig.savefig resizes the colorbar relative to when bbox_inches is not set. The colorbar becomes larger than it should be.",
            "stepsToReproduce": [
                "Import numpy, matplotlib, and matplotlib.pyplot",
                "Create a meshgrid and a pcolormesh plot",
                "Add a colorbar to the plot",
                "Uncomment the first fig.savefig to get the correct output on the second call",
                "Save the figure with bbox_inches set to a specified Bbox"
            ],
            "expectedResults": "The colorbar should not resize when bbox_inches is set.",
            "actualResults": "The colorbar resizes relative to when bbox_inches is not set.",
            "supplementaryImages": [
                "Colorbar with bbox_inches set to Bbox",
                "Colorbar with bbox_inches set to 'tight'"
            ],
            "additionalNotes": "Calling fig.savefig without bbox_inches set first and then calling it again with bbox_inches set produces the expected outcome. Calling plt.show() prior to savefig also works."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-25565",
        "structure_problem": {
            "problemSummary": "Failed to generate a legend for a Poly3dCollection object in a 3D plot.",
            "context": "The issue occurs when attempting to add a legend to a 3D plot created using Poly3dCollection from the marching_cubes function. The legend is supposed to be inserted but results in an AttributeError.",
            "stepsToReproduce": [
                "1. Generate an iso surface using the marching_cubes function.",
                "2. Create a Poly3dCollection object from the verts and faces obtained from marching_cubes.",
                "3. Add the Poly3dCollection to a 3D plot.",
                "4. Attempt to add a legend to the plot."
            ],
            "expectedResults": "The legend should be successfully inserted into the 3D plot.",
            "actualResults": "An AttributeError is raised, indicating that the 'tuple' object has no attribute 'size'.",
            "supplementaryImages": [
                "A 3D plot with two intersecting ellipsoids represented by a Poly3dCollection."
            ],
            "additionalNotes": "The error occurs because the `first_color` function in matplotlib's legend_handler.py assumes `colors` is a numpy array, which has a 'size' attribute. However, with Poly3dCollection, `colors` is already a tuple, leading to the AttributeError. A quick fix is suggested: converting `colors` to a numpy array to ensure it has the 'size' attribute."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-25640",
        "structure_problem": {
            "problemSummary": "Contour labels in a plot extend beyond the figure boundary when using the PGF backend.",
            "context": "The issue was originally posted as a question on StackOverflow and occurs with specific versions of Ubuntu, Matplotlib, and Python.",
            "stepsToReproduce": [
                "Import necessary libraries (matplotlib, numpy, matplotlib.cm, matplotlib.mlab, matplotlib.pyplot).",
                "Set matplotlib parameters for xtick and ytick direction.",
                "Define a range of x and y values.",
                "Create a meshgrid from x and y.",
                "Calculate a bivariate normal distribution.",
                "Create a difference of Gaussians from the bivariate normal distributions.",
                "Plot a contour with labels using the calculated data.",
                "Save the plot using the PGF backend."
            ],
            "expectedResults": "The contour label at the top should be clipped to the figure boundary.",
            "actualResults": "Contour labels extend beyond the figure boundary.",
            "supplementaryImages": [
                "A contour plot with labels extending beyond the figure boundary."
            ],
            "additionalNotes": "The issue was reported with Ubuntu 17.10, Matplotlib version 2.2.2, and Python 3.6.3. The backend used was PGF."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-25667",
        "structure_problem": {
            "problemSummary": "The `bar` and `barh` functions in Matplotlib do not correctly handle datetime units for the `bottom` and `left` parameters, leading to incorrect axis conversion.",
            "context": "The issue arises when attempting to create horizontal or vertical bar plots with datetime data. The functions do not check the units of the `bottom` or `left` parameters, which are necessary to properly convert the axis units.",
            "stepsToReproduce": [
                "1. Import necessary libraries (numpy, matplotlib.pyplot).",
                "2. Define datetime arrays for start and stop times.",
                "3. Create a figure and axis using `plt.subplots()`.",
                "4. Call `ax.barh([0, 1, 3], width=stop-start, left=start)` or `ax.bar([0, 1, 3], height=stop-start, bottom=start)`."
            ],
            "expectedResults": "The axis should correctly convert and display the datetime units for the bars.",
            "actualResults": "The axis does not correctly convert the datetime units for the bars.",
            "supplementaryImages": [
                "Images showing the incorrect conversion of datetime units on the axis."
            ],
            "additionalNotes": "Setting `plt.rcParams['date.converter'] = 'concise'` and using a workaround with a plot line to force axis conversion temporarily solves the issue."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-25779",
        "structure_problem": {
            "problemSummary": "User is trying to plot an ellipse with an arrow showing rotation clockwise or counterclockwise but is unsure how to implement this feature.",
            "context": "The user is using matplotlib to plot ellipses and is looking for a way to add an arrow indicating the direction of rotation.",
            "stepsToReproduce": [
                "Attempt to plot an ellipse using matplotlib.",
                "Try to add an arrow to the ellipse to indicate rotation direction."
            ],
            "expectedResults": "The user expects to be able to plot an ellipse with an arrow indicating the direction of rotation.",
            "actualResults": "The user is unable to implement the arrow feature.",
            "supplementaryImages": [
                "Two images showing an ellipse with an arrow indicating rotation direction."
            ],
            "additionalNotes": "The user is considering adding this feature as an optional argument."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-26078",
        "structure_problem": {
            "problemSummary": "When plotting on a parasite axis using `axes_grid1.parasite_axes`, units are not automatically applied to the parasite axis.",
            "context": "The issue arises due to a specific line of code in `ParasiteAxesBase.cla`, which causes `ax2.plot` to attempt to call `update_units` on the host axes instead of the parasite axes.",
            "stepsToReproduce": [
                "Create a host subplot using `host_subplot(111, axes_class=axisartist.Axes)`.",
                "Plot a line on the host axis using `host.plot([0, 1, 2], [Volt(x) for x in (0, 1, 2)])`.",
                "Create a parasite axis using `host.twinx()`.",
                "Plot a line on the parasite axis using `par1.plot([0, 1, 2], [Amp(x) for x in (0, 3, 2)])`.",
                "Display the plot using `plt.show()`."
            ],
            "expectedResults": "The units should be correctly applied to the parasite axis.",
            "actualResults": "Units are not automatically applied to the parasite axis.",
            "supplementaryImages": [
                "The first image shows the plot with two lines, one in volts and one in amperes.",
                "The second image is supposed to show the expected outcome with units properly applied to the parasite axis."
            ],
            "additionalNotes": "The issue appears to be related to the line of code in `ParasiteAxesBase.cla` that sets `self._get_lines = self._parent_axes._get_lines`. A fix has been suggested by changing this line and modifying related functions."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-26466",
        "structure_problem": {
            "problemSummary": "When an array is used as the 'xy' kwarg for an annotation that includes arrows, changing the array after calling the function changes the arrow position. It is likely that the same array is kept instead of a copy.",
            "context": "The issue occurs in matplotlib version 3.0.3 on Debian 9 with Python 3.5.3.",
            "stepsToReproduce": [
                "Create a figure and add an axes.",
                "Set the x and y limits for the axes.",
                "Create two arrays 'xy_0' and 'xy_f'.",
                "Use 'ax.annotate' with 'xy=xy_0', 'xytext=xy_f', and arrow properties.",
                "Modify 'xy_0[1]' to update the array.",
                "Create another annotation using a copy of 'xy_0' and modify 'xy_0[1]' again."
            ],
            "expectedResults": "Both arrows should remain horizontal.",
            "actualResults": "The arrow position changes when the array is modified.",
            "supplementaryImages": [
                "The provided image shows the actual outcome with one arrow changing position."
            ],
            "additionalNotes": "Using a copy of the array helps in identifying where the problem lies."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-2576",
        "structure_problem": {
            "problemSummary": "The `lmplot` function in seaborn is not properly adjusting the y-axis scale for different subplots when `sharey=False` is specified, leading to an issue where the y-axis scale does not adapt to the data ranges of individual subplots.",
            "context": "The issue was encountered while trying to use `lmplot` with the `sharey=False` parameter to create subplots with separate y-axis scales. The expected behavior was for each subplot to have its own y-axis scale that would adjust based on the data points within that subplot. However, the actual behavior resulted in each subplot using the same y-axis scale, which was not appropriate for the data distribution.",
            "stepsToReproduce": [
                "Create a DataFrame with 'x', 'y', and 't' columns.",
                "Use `sns.lmplot` with `data=df`, `x='x'`, `y='y'`, `col='t'`, and `sharey=False` to generate subplots."
            ],
            "expectedResults": "Each subplot should have its own y-axis scale that is adjusted based on the data points within that subplot.",
            "actualResults": "All subplots share the same y-axis scale, regardless of the data distribution within each subplot.",
            "supplementaryImages": [
                "lmplot with sharey=False (issue example)",
                "lmplot with sharex=False and sharey=False (expected behavior example)"
            ],
            "additionalNotes": "The issue was resolved by including `sharex=False` in the `lmplot` function call, which forced the function to adjust both the x and y-axis scales independently for each subplot."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-2846",
        "structure_problem": {
            "problemSummary": "The issue is that the `relplot` function in seaborn does not handle numpy types for dimensional variables correctly. It works fine with the `y` parameter but does not create two columns or give useful feedback when numpy types are used for the `col` parameter.",
            "context": "This problem was noticed while trying to use the `relplot` function with numpy types for dimensional variables. The `displot` function handles similar situations better.",
            "stepsToReproductive": [
                "Import the seaborn library and the dataset (in this case, `tips`).",
                "Use the `relplot` function with the `x`, `y`, and `col` parameters, where the `col` parameter is set to a numpy array derived from the `time` column of the dataset.",
                "Observe that the function does not create two columns as expected or provide useful feedback about the issue."
            ],
            "expectedResults": "The `relplot` function should create two columns based on the numpy array used for the `col` parameter or provide clear feedback about why it cannot handle numpy types for dimensional variables.",
            "actualResults": "The `relplot` function does not create two columns and does not provide useful feedback about the issue.",
            "supplementaryImages": [
                "The first image shows the expected scatter plot with two columns based on the numpy array for the `col` parameter.",
                "The second image shows the actual scatter plot with a single column, indicating that the `col` parameter with a numpy array was not handled correctly."
            ],
            "additionalNotes": "The `displot` function handles similar situations better, as it does not create two columns but does not give a misleading y axis label like `relplot` does."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-2979",
        "structure_problem": {
            "problemSummary": "The visibility of internal axis labels is incorrect in a wrapped pair plot, causing the top two subplots to have indistinct x labels.",
            "context": "The issue arises when creating a wrapped pair plot that includes multiple variables. The expected behavior is for each subplot to have distinct x labels, but the current implementation results in the top two subplots sharing the same x label.",
            "stepsToReproduce": [
                "Create a wrapped pair plot using the `pair` method with the `wrap` parameter set to 2.",
                "Observe the x labels of the top two subplots."
            ],
            "expectedResults": "Each subplot should have distinct x labels.",
            "actualResults": "The top two subplots have indistinct x labels.",
            "supplementaryImages": [
                "Image 1: `so.Plot(mpg, y=\"mpg\").pair([\"displacement\", \"weight\", \"horsepower\", \"cylinders\"], wrap=2)`"
            ],
            "additionalNotes": "The wrapped pair plot is created by specifying the `wrap` parameter in the `pair` method. The issue affects the visibility of internal axis labels, particularly in the top two subplots."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-3180",
        "structure_problem": {
            "problemSummary": "Overlapping labels in relplot with seaborn 0.12",
            "context": "The issue arises when using seaborn's relplot function with a dataset that has been scaled by 1e7 and then reset the index. The problem is observed in seaborn 0.12 and persists in versions 11.2 and 12.1.",
            "stepsToReproduce": [
                "Load the iris dataset using seaborn's load_dataset function.",
                "Scale the dataset by 1e7 and reset the index.",
                "Use seaborn's relplot function with the scaled dataset, specifying x='sepal_length', y='sepal_width', col='species', col_wrap=2, and height=2.5.",
                "Set the titles for the rows and columns using the set_titles method.",
                "Format the tick labels using the ticklabel_format method."
            ],
            "expectedResults": "The relplot should display the data without overlapping labels.",
            "actualResults": "The relplot displays the data with overlapping labels.",
            "supplementaryImages": [
                "The first image shows the relplot with overlapping labels when using seaborn 0.12.",
                "The second image shows the relplot with overlapping labels when using seaborn 11.2.",
                "The third image shows the relplot with overlapping labels when using seaborn 12.1."
            ],
            "additionalNotes": "The issue persists across different versions of seaborn."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-3187",
        "structure_problem": {
            "problemSummary": "The legend values for large ranges in a seaborn plot are not formatted correctly, displaying incorrect values without the multiplicative offset.",
            "context": "The issue is observed in seaborn version 0.12.1 when creating plots with large number values, specifically when using the `ScalarFormatter` with an offset. The code example provided uses a dataset of penguins and plots the bill length and depth against the body mass in milligrams.",
            "stepsToReproduce": [
                "Load the penguins dataset and convert the body mass from grams to milligrams.",
                "Create a seaborn plot using the `Plot` object with `x`, `y`, `color`, and `pointsize` mappings.",
                "Add a `Dot` layer to the plot."
            ],
            "expectedResults": "The legend values should correctly reflect the multiplicative offset for large ranges.",
            "actualResults": "The legend values are displayed without the multiplicative offset, leading to incorrect values.",
            "supplementaryImages": [
                "A scatter plot of penguin data showing the bill length and depth with different species colored and sized by body mass."
            ],
            "additionalNotes": "The issue is suspected to be related to the handling of the offset value in the `ScalarFormatter` used in seaborn's scales. The rcParam settings `axes.formatter.useoffset` and `axes.formatter.offset_threshold` may also be relevant, but this has not been tested."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-3202",
        "structure_problem": {
            "problemSummary": "When using the seaborn.objects interface to facet data on partially crossed row and column variables, a ValueError is raised.",
            "context": "The issue occurs when attempting to create a faceted plot using the seaborn.objects interface with partially crossed categories.",
            "stepsToReproduce": [
                "Load the penguins dataset using seaborn.load_dataset()",
                "Drop any NaN values from the dataset",
                "Create a faceted plot using the objects interface with 'species' as columns and 'island' as rows",
                "Add dots to the plot"
            ],
            "expectedResults": "Facets that contain no data should be empty, similar to the behavior of catplot in seaborn.",
            "actualResults": "A ValueError is raised.",
            "supplementaryImages": [
                "Faceted plot with partially crossed categories"
            ],
            "additionalNotes": "The error message indicates that the vectorize function cannot handle size 0 inputs unless 'otypes' is set."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-3216",
        "structure_problem": {
            "problemSummary": "A title is missing from a plot when using seaborn's objects API with subfigures.",
            "context": "The issue is observed when plotting on subfigures with seaborn's objects API.",
            "stepsToReproduce": [
                "Import seaborn and matplotlib.",
                "Create a figure with subfigures.",
                "Load a dataset with seaborn.",
                "Use the objects API to add a bar chart and histogram to one subfigure.",
                "Plot a scatter plot on the other subfigure.",
                "Add a supertitle to the figure.",
                "Display the plot."
            ],
            "expectedResults": "The supertitle should appear on the plot.",
            "actualResults": "The supertitle is missing from the plot.",
            "additionalNotes": "Commenting out the plot command on the subfigure with the bar chart and histogram causes the title to reappear. Modifying line 186 in the _core/subplots.py file from 'figure = target.figure' to 'figure = target' seems to resolve the issue."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-3217",
        "structure_problem": {
            "problemSummary": "Histogram plot with log scale on the x-axis is showing a slight overlap issue with bar widths, which becomes nearly imperceptible with more bins.",
            "context": "The issue occurs when plotting a histogram with a log scale on the x-axis and using bars with a specified width. The overlap is noticeable with fewer bins but becomes less apparent with more bins.",
            "stepsToReproduce": [
                "Create a histogram plot using a dataset with a variable named 'total_bill'.",
                "Apply the log scale to the x-axis using the scale function.",
                "Add bars to the plot with a specified width and no edgewidth."
            ],
            "expectedResults": "Bars on the histogram should not overlap when using a log scale on the x-axis.",
            "actualResults": "Bars on the histogram slightly overlap when using a log scale on the x-axis, especially with fewer bins.",
            "supplementaryImages": [
                "Histogram plot with 4 bins showing slight overlap.",
                "Histogram plot with 8 bins showing nearly imperceptible overlap.",
                "Additional image showing the same issue with the Bar element."
            ],
            "additionalNotes": "This issue affects both Bars and Bar elements in the histogram plot."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-3276",
        "structure_problem": {
            "problemSummary": "Heatmap behaves differently when `norm=None` is passed.",
            "context": "The user observed a discrepancy in the behavior of `sns.heatmap` when using the `norm` argument.",
            "stepsToReproduce": [
                "Use `sns.heatmap(..., vmin=0.0, vmax=1.0, ...)`",
                "Observe the heatmap",
                "Use `sns.heatmap(..., vmin=0.0, vmax=1.0, norm=None, ...)`",
                "Observe the heatmap"
            ],
            "expectedResults": "The `vmin` and `vmax` should be respected regardless of the `norm` argument.",
            "actualResults": "When `norm=None` is used, the `vmin` and `vmax` are lost.",
            "supplementaryImages": [
                "Two heatmaps showing the difference in behavior with and without `norm=None`"
            ],
            "additionalNotes": "The user is willing to submit a PR if the issue is not already addressed."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-3394",
        "structure_problem": {
            "problemSummary": "When plotting data with pandas NaN values, the axis ordering is reversed into descending order.",
            "context": "The issue was encountered when plotting data with pandas NaN values. The expected behavior was for the NaN values to be excluded without reversing the axis order.",
            "stepsToReproduce": [
                "Create a DataFrame with data points and NaN values.",
                "Use seaborn's `FacetGrid` to plot the data with different types of NaN values.",
                "Observe the reversed axis ordering when using pandas NaN values."
            ],
            "expectedResults": "The NaN values should be excluded without reversing the axis order.",
            "actualResults": "The axis ordering is reversed into descending order when using pandas NaN values.",
            "supplementaryImages": [
                "Three line plots showing the differences in axis ordering when using no NaN values, pandas NaN values, and numpy NaN values."
            ],
            "additionalNotes": "Using numpy NaN values does not produce the issue of reversed axis ordering."
        }
    },
    {
        "instance_id": "pydata__xarray-4182",
        "structure_problem": {
            "problemSummary": "Proposal to pre-expand data and attributes in DataArray/Variable HTML representation for better discoverability and consistency with text representation.",
            "context": "The current HTML representation for DataArray/Variable requires users to click on an icon to expand sections to view array data and attributes. This is not easily discoverable and is inconsistent with the text representation which shows these sections by default. The proposal aims to improve this by pre-expanding these sections.",
            "stepsToReReproduce": [
                "Load a dataset and access a DataArray.",
                "Observe the HTML representation of the DataArray."
            ],
            "expectedResults": "Array data and attributes are pre-expanded and visible by default in the HTML representation.",
            "actualResults": "Array data and attributes are hidden and require clicking on an icon to view.",
            "supplementaryImages": [
                "Image 1: DataArray HTML representation with collapsed data and attributes.",
                "Image 2: Expanded view of array data and attributes after clicking the icon.",
                "Image 3: Improved representation of nested dask arrays."
            ],
            "additionalNotes": "This proposal seeks to enhance user experience by making it easier to access data and attributes. It also aims to maintain consistency between text and HTML representations."
        }
    },
    {
        "instance_id": "pydata__xarray-5682",
        "structure_problem": {
            "problemSummary": "When plotting a variable with a complex LaTeX expression as its `long_name` using xarray, the expression is not rendered correctly, unlike when using only matplotlib.",
            "context": "The issue occurs when attempting to plot a variable with a `long_name` that includes complex LaTeX expressions, specifically when using xarray for plotting. The same expression renders correctly when plotted using matplotlib directly.",
            "stepsToReproduce": [
                "Create a DataArray with a complex LaTeX expression in its `long_name` attribute.",
                "Plot the DataArray using xarray's plotting functionality.",
                "Observe that the LaTeX expression is not rendered correctly."
            ],
            "expectedResults": "The LaTeX expression in the `long_name` should be rendered correctly when plotting the DataArray with xarray.",
            "actualResults": "The LaTeX expression in the `long_name` is not rendered correctly when plotted with xarray.",
            "supplementaryImages": [
                "Two figures are provided: one showing the incorrect rendering of the LaTeX expression when using xarray for plotting (left), and another showing the correct rendering when using matplotlib directly (right)."
            ],
            "additionalNotes": "The environment details indicate the versions of the libraries used and confirm that the issue is specific to xarray's plotting capabilities."
        }
    },
    {
        "instance_id": "pylint-dev__pylint-4551",
        "structure_problem": {
            "problemSummary": "The issue is about the behavior of pyreverse when generating UML diagrams from Python code. It does not read Python type hints, specifically when `None` is used as a default value.",
            "context": "The user has provided a code snippet with a class `C` having an attribute `a` with a default value of `None`. The expected behavior is for pyreverse to interpret the type hint and display the type of `a` in the UML diagram as `String`. However, the actual behavior is that pyreverse does not recognize the type hint and does not display the type of `a`.",
            "stepsToReproduce": [
                "Define a class with an attribute using a type hint with a default value of `None`.",
                "Use pyreverse to generate a UML diagram from the code.",
                "Observe that the type of the attribute is not displayed in the UML diagram."
            ],
            "expectedResults": "The UML diagram should display the type of the attribute `a` as `String`.",
            "actualResults": "The UML diagram does not display the type of the attribute `a`.",
            "supplementaryImages": [
                "The UML diagram generated by pyreverse does not show the type of the attribute `a`."
            ],
            "additionalNotes": "The user has provided information about their Python environment, which includes the version of pylint, astroid, and their Python interpreter."
        }
    },
    {
        "instance_id": "scikit-learn__scikit-learn-13087",
        "structure_problem": {
            "problemSummary": "Feature request for arbitrary bin spacing in sklearn's calibration_curve function.",
            "context": "The user is working with a gradient boosting model where the predicted probabilities are uncalibrated, leading to noisy results when using the default binning in sklearn's calibration_curve. The user proposes a workaround to manually specify bin edges and requests support for this feature in sklearn.",
            "stepsToReproduce": [
                "Import necessary libraries (numpy, sklearn).",
                "Use sklearn's calibration_curve with default binning.",
                "Observe noisy results due to uneven distribution of predictions."
            ],
            "expectedResults": "The user expects to be able to specify arbitrary bin edges for the calibration curve.",
            "actualResults": "The current implementation of sklearn's calibration_curve only allows for specifying the number of bins, leading to uneven distribution of predictions across bins.",
            "supplementaryImages": [
                {
                    "description": "Comparison plot between default binning and user's manual binning."
                }
            ],
            "additionalNotes": "The user is open to contributing a pull request if the feature is deemed useful by the community."
        }
    },
    {
        "instance_id": "scikit-learn__scikit-learn-13618",
        "structure_problem": {
            "problemSummary": "The user encountered issues with default initial values of hyperparameters in the BayesianRidge model when trying to fit a sinusoidal curve with polynomials. The initial values did not yield satisfactory results, necessitating the ability to set custom initial values for better regression performance.",
            "context": "The user modified the `fit` method of the `BayesianRidge` class to allow setting initial hyperparameters (alpha and lambda) for fitting a sinusoidal curve with polynomials.",
            "stepsToReproduce": [
                "Fit a sinusoidal curve using the default `BayesianRidge` implementation for polynomial fitting.",
                "Observe that the default initial hyperparameters do not yield satisfactory results.",
                "Propose modifications to the `fit` method of the `BayesianRidge` class to allow setting initial values of hyperparameters (alpha and lambda).",
                "Use the modified `BayesianRidge` implementation with custom initial hyperparameters to fit the sinusoidal curve."
            ],
            "expectedResults": "The user expected the sinusoidal curve regression to work well with custom initial hyperparameters.",
            "actualResults": "The default initial values in `BayesianRidge` did not work well for fitting a sinusoidal curve with polynomials.",
            "supplementaryImages": [
                "Left figure: BayesianRidge fit with default initial hyperparameters showing unsatisfactory results.",
                "Right figure: BayesianRidge fit with custom initial hyperparameters showing improved results."
            ],
            "additionalNotes": "The user implemented and tested the proposed modification, observing improved regression performance with custom initial hyperparameters compared to the default values."
        }
    },
    {
        "instance_id": "scikit-learn__scikit-learn-14067",
        "structure_problem": {
            "problemSummary": "The accuracy of the ARD Regressor degrades when upgrading Scipy from version 1.2.1 to 1.3.0.",
            "context": "On a simple dataset where a near-perfect fit should be achievable, the typical error increases from an order of 1E-5 to 1E-2 when upgrading Scipy. The convergence iterations also increase from ~5 to around 50-200.",
            "expectedResults": "A near-perfect fit with an error close to 0.",
            "actualResults": "Increased error and more iterations for convergence.",
            "supplementaryImages": [
                "A histogram showing the absolute co-efficient error when fit across 1000 datasets generated with different random seeds."
            ],
            "additionalNotes": "This issue might be related to Scipy rather than Sklearn, and it could be a weirdness of the toy example, but the difference in behavior seems significant."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-10048",
        "structure_problem": {
            "problemSummary": "Sphinx-generated tooltips for headings use 'Headline' instead of 'Heading'.",
            "context": "The issue was discovered while building Sphinx documentation containing one or more headings. The expected tooltip for the Sphinx-injected 'headerlink' should say 'Permalink to this heading' instead of 'Permalink to this headline'.",
            "stepsToReproduce": [
                "1. Build any Sphinx documentation containing headings.",
                "2. Hover over the Sphinx-injected 'headerlink'.",
                "3. Observe the tooltip that appears."
            ],
            "expectedResults": "Tooltip should say 'Permalink to this heading'.",
            "actualResults": "Tooltip says 'Permalink to this headline'.",
            "supplementaryImages": [
                "An image of a tooltip with the text 'Permalink to this headline'."
            ],
            "additionalNotes": "The relevant code snippet is from the Sphinx repository (https://github.com/sphinx-doc/sphinx/blob/f38bd8e9529d50e5cceffe3ca55be4b758529ff7/sphinx/writers/html5.py#L386-L398). This issue might require an update to translated strings and could be addressed in Sphinx 5.0+."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-10097",
        "structure_problem": {
            "problemSummary": "Issue with long option names overflowing in the index when using xelatex in Sphinx documentation.",
            "context": "The user is encountering a formatting issue where long option names, such as `-Wauggest-attribute=[pure|const|noreturn|format|cold|malloc]`, overflow in the index of the Sphinx-generated documentation when using xelatex. This problem is observed when building a snippet of documentation.",
            "stepsToReproduce": [
                "Create a Sphinx documentation project.",
                "Add a long option name, such as `-Wauggest-attribute=[pure|const|noreturn|format|cold|malloc]`, to the documentation.",
                "Build the documentation using xelatex."
            ],
            "expectedResults": "The long option names should be properly formatted and not overflow in the index.",
            "actualResults": "The long option names overflow in the index.",
            "supplementaryImages": [
                "Image showing the overflow in the index."
            ],
            "additionalNotes": "The issue is observed on Linux with Python 3.8 and Sphinx version 4.3.0."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-10191",
        "structure_problem": {
            "problemSummary": "Footnote marks are rendered as '?' and there is no hyperlink in LaTeX PDF output when using Sphinx with explicit numbered footnotes.",
            "context": "The issue occurs when explicitly numbered footnotes are referenced multiple times in the document.",
            "stepsToReproduce": [
                "Create a reStructuredText file with explicit numbered footnotes.",
                "Reference the footnotes multiple times within the text.",
                "Run `make latexpdf` to generate the LaTeX PDF output."
            ],
            "expectedResults": "Footnotes should be rendered correctly in the LaTeX PDF output.",
            "actualResults": "Footnotes are rendered as '?' and there is no hyperlink in the LaTeX PDF output.",
            "supplementaryImages": [
                "Screenshots showing the incorrect rendering of footnotes."
            ],
            "additionalNotes": "The issue is observed on a Mac with Python 3.8.7 and Sphinx version 4.4.0 and current 4.x (v4.5.0+/4ba056870)."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-10435",
        "structure_problem": {
            "problemSummary": "The Sphinx syntax highlighting for the Docutiles `code` role adds whitespace at the start and end of inline code in LaTeX output.",
            "context": "This issue was discovered after the merge of #10251, which activated syntax highlighting for the `code` role.",
            "stepsToReproduce": [
                "Create a file named `index.rst` with the following content:",
                "```",
                ".. role:: python(code)",
                "   :language: python",
                "   :class: highlight",
                "",
                "Inline :python:`def foo(1 + 2 + None + \"abc\"): pass` code block",
                "",
                ".. code-block:: python",
                "",
                "def foo(1 + 2 + None + \"abc\"): pass",
                "```",
                "Run `make latexpdf` to generate the LaTeX output."
            ],
            "expectedResults": "The inline code should not have whitespace at the start and end.",
            "actualResults": "Whitespace is added at the start and end of the inline code in the LaTeX output.",
            "supplementaryImages": [
                "Images showing the current behavior with whitespace, the behavior without whitespace, and the behavior before the #10251 merge."
            ],
            "additionalNotes": "The issue is specific to LaTeX output and was observed on a Mac with Python 3.9 and Sphinx 5.x."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-11266",
        "structure_problem": {
            "problemSummary": "LaTeX issue with missing space before colon after 'Voir aussi' for seealso directive in French.",
            "context": "The problem occurred after upgrading to Sphinx 6.1.0.",
            "stepsToReproduce": [
                "Create a LaTeX document with French language settings.",
                "Use the 'seealso' directive.",
                "Note the absence of a space before the colon after 'Voir aussi'."
            ],
            "expectedResults": "A space should be present before the colon after 'Voir aussi'.",
            "actualResults": "No space is present before the colon after 'Voir aussi'.",
            "additionalNotes": "This issue was introduced in Sphinx 6.1.0 and was caused by a fix for another issue (#11080)."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-11502",
        "structure_problem": {
            "problemSummary": "User wants to keep the 'translated' node attribute to mark untranslated or partially translated pages in internationalized documentation.",
            "context": "The user is duplicating part of the 'Locale' transform to add markers for untranslated pages. The 'Locale' transform already sets an attribute on translated nodes but deletes it at the end, which the user finds clumsy.",
            "stepsToReproduce": [
                "Duplicate the functionality of the 'Locale' transform to add markers for untranslated pages.",
                "Notice that the 'translated' attribute is set on translated nodes and then deleted."
            ],
            "expectedResults": "The user expects to be able to keep the 'translated' attribute to mark untranslated or partially translated pages.",
            "actualResults": "The 'translated' attribute is deleted at the end of the 'Locale' transform.",
            "supplementaryImages": [
                "Note: Cette page n'est pas encore complÃ¨tement traduite (avancement : 95%)."
            ],
            "additionalNotes": "The user has considered adding the functionality for 'untranslated' markers to Sphinx itself as an alternative."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-7757",
        "structure_problem": {
            "problemSummary": "The default value for a positional only argument in a Python function documentation has disappeared.",
            "context": "The user is documenting a Python function with positional only arguments and default values using Sphinx. The issue arises when the default value for a positional only argument is not displayed in the generated documentation.",
            "stepsToReproduce": [
                "Create a file with Sphinx documentation for a Python function."
            ],
            "expectedResults": "The default value for the positional only argument should be shown in the generated documentation.",
            "actualResults": "The default value for the positional only argument is not shown in the generated documentation.",
            "supplementaryImages": [
                "An image showing the correct documentation with the default value displayed."
            ],
            "additionalNotes": "The user is using a Mac with Python 3.8.2 and Sphinx version 3.1.0dev."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-8028",
        "structure_problem": {
            "problemSummary": "Instance attributes are omitted when using the autosummary in Sphinx documentation. This issue is a followup of #7948.",
            "context": "The problem occurs when documenting a class with both class and instance attributes using Sphinx's autosummary directive. The instance attributes are not documented, even though autodoc directive includes them.",
            "stepsToReproduce": [
                "Create a class with both a class attribute and an instance attribute.",
                "Use autosummary directive in the documentation to include both attributes.",
                "Build the documentation and observe that only the class attribute is documented."
            ],
            "expectedResults": "Instance attributes should be documented along with class attributes when using autosummary.",
            "actualResults": "Instance attributes are not documented when using autosummary.",
            "supplementaryImages": [
                "Screenshot of index.html showing the documentation with only the class attribute."
            ],
            "additionalNotes": "The issue did not occur in Sphinx versions prior to 3.1."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-8056",
        "structure_problem": {
            "problemSummary": "Render error when combining multiple input parameters in docstring",
            "context": "The user is writing a function in Python and wants to combine multiple similar input parameters in the same line in the docstring, following the numpydoc format. However, this results in a render error in the HTML output.",
            "stepsToReproduce": [
                "Write a function with multiple input parameters in the docstring.",
                "Combine the input parameters in the same line using the numpydoc format.",
                "Build the documentation using Sphinx."
            ],
            "expectedResults": "The docstring should render correctly with the combined parameters formatted as expected.",
            "actualResults": "The HTML output shows a render error for the combined parameters.",
            "supplementaryImages": [
                "An image of the rendered HTML showing the render error."
            ],
            "additionalNotes": "The issue occurs even when marking the parameters as optional. The user's environment includes macOS 10.15.5, Python 3.7.7, and Sphinx 3.0.3, with various Sphinx extensions enabled."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-8075",
        "structure_problem": {
            "problemSummary": "Using figures without captions in Sphinx documentation causes errors in both HTML and LaTeX output.",
            "context": "The issue was observed when using figures without captions in a Sphinx documentation project. The project was generated with Sphinx 2.2.2, and the `numfig=True` option was set in `conf.py`. The problem manifests as errors in both HTML and LaTeX output, with warnings about undefined references in LaTeX and misleading warnings in HTML.",
            "stepsToReproduce": [
                "Create a Sphinx documentation project.",
                "Add a figure without a caption.",
                "Reference the figure using :ref: and :numref: in the Sphinx source.",
                "Build the documentation with Sphinx."
            ],
            "expectedResults": "Sphinx should produce valid LaTeX input without undefined references, and uncaptioned figures should be referenceable in LaTeX.",
            "actualResults": "Sphinx produces errors in both HTML and LaTeX output, including warnings about undefined references in LaTeX and misleading warnings in HTML.",
            "supplementaryImages": [
                "HTML output with highlighted error",
                "LaTeX output with errors about undefined references",
                "Test document structure and references"
            ],
            "additionalNotes": "The user expects the warning about figures not being captioned to be more meaningful, and suggests that uncaptioned figures could be referenceable in LaTeX with an optional setting."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-8120",
        "structure_problem": {
            "problemSummary": "The user is unable to override translations for Sphinx documentation using a custom `sphinx.po` file in the locale directory. The official translations are being used instead.",
            "context": "The user has added a custom `sphinx.po` file with updated translations to the locale directory and has ensured that `gettext_auto_build = True` and `language = 'da'` in `conf.py`. Despite this, the custom translations are not being applied.",
            "stepsToReproduce": [
                "Clone the repository from https://github.com/jonascj/sphinx-test-locale-override.git",
                "Switch to the commit `8dea4cd` for the bug",
                "Create a Python virtual environment and install Sphinx",
                "Run `make html` to build the documentation",
                "Open `_build/html/index.html` and observe the figure and code block captions"
            ],
            "expectedResults": "The figure caption label should be 'Foobar 1' and the code block caption label should be 'Whatever 1' as specified in the custom `sphinx.po` file.",
            "actualResults": "The figure caption label remains 'figur 1' and the code block caption label remains 'Viser 1', using the official translations.",
            "supplementaryImages": [
                "Screenshots of the documentation showing the figure and code block captions"
            ],
            "additionalNotes": "The current master branch of the repository includes a workaround, so the bug is observed when reverting to the commit `8dea4cd`."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-8265",
        "structure_problem": {
            "problemSummary": "Documentation issue where default arguments in the docstring are not rendered correctly in HTML.",
            "context": "The issue occurs in the Sphinx-generated documentation for a Python class method, specifically for the `add_lines` method. The default arguments for `color` are not being displayed correctly in the HTML output.",
            "stepsToReproduce": [
                "Clone the repository from https://github.com/tkoyama010/pyvista.git.",
                "Navigate to the directory and install the package with `pip install .`.",
                "Install required dependencies with `pip install -r requirements_docs.txt`.",
                "Build the documentation with `make html` in the `docs` directory."
            ],
            "expectedResults": "The default arguments for `color` in the `add_lines` method should be displayed as `color=(1, 1, 1)` in the HTML output.",
            "actualResults": "The default arguments for `color` are displayed as `color=1, 1, 1` in the HTML output.",
            "supplementaryImages": [
                "Screenshots showing the incorrect rendering of default arguments in the HTML documentation."
            ],
            "additionalNotes": "The issue appears to be related to the Sphinx version (3.1.1) and the presence of certain Sphinx extensions (e.g., `sphinx.ext.autodoc`)."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-8278",
        "structure_problem": {
            "problemSummary": "Sphinx 3.2.1 changes hexadecimal default arguments to decimal in function documentation.",
            "context": "When documenting a function with a hexadecimal default argument, Sphinx renders the documentation in decimal instead of the expected hexadecimal, leading to confusion in interpreting the value.",
            "stepsToReproduce": [
                "Document a function with a hexadecimal default argument.",
                "Build the documentation with Sphinx 3.2.1.",
                "Observe the rendered HTML documentation."
            ],
            "expectedResults": "The documentation should display the hexadecimal value as typed by the user.",
            "actualResults": "The documentation displays the hexadecimal value converted to decimal.",
            "supplementaryImages": [
                "Images showing the expected hexadecimal value and the actual decimal value in the documentation."
            ],
            "additionalNotes": "This issue affects the readability and understanding of the documentation, especially for hexadecimal values like colors or file permissions."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-8620",
        "structure_problem": {
            "problemSummary": "The `:kbd:` role in Sphinx generates HTML that is difficult/impossible to style for compound keystrokes due to the lack of differentiation between parent container and child `<kbd>` elements.",
            "context": "The issue arises when styling compound keystrokes, where the parent container `<kbd>` element cannot be differentiated from child `<kbd>` elements using CSS selectors.",
            "stepsToReproduce": [
                "Use `:kbd:` for a single keystroke (e.g., `:kbd:`A`)`.",
                "Use `:kbd:` for a compound keystroke (e.g., `:kbd:`Shift+X`)`."
            ],
            "expectedResults": "Single keystrokes should remain unchanged, while compound keystrokes should have the parent container `<kbd>` element marked with a CSS class (e.g., `compound`) to differentiate it from child `<kbd>` elements.",
            "actualResults": "The HTML generated by the `:kbd:` role does not differentiate between parent container and child `<kbd>` elements, making it difficult/impossible to style compound keystrokes.",
            "supplementaryImages": [
                "Image of a compound keystroke with a double border"
            ],
            "additionalNotes": "The issue affects styling of compound keystrokes in Sphinx documentation, particularly when using CSS to differentiate between single and compound keystrokes."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-8621",
        "structure_problem": {
            "problemSummary": "The `:kbd:` role in Sphinx produces incorrect HTML when compound-key separators (-, + or ^) are used as keystrokes in standalone or compound keystrokes.",
            "context": "The issue arises when the `-`, `+`, or `^` characters are used in keyboard definitions. These characters are misinterpreted as separators rather than actual keystrokes.",
            "stepsToReproduce": [
                "Define a standalone keystroke using a compound-key separator (e.g., :kbd:`-`).",
                "Define a compound keystroke where one or more keystrokes use a compound-key separator (e.g., :kbd:`Shift-+`)."
            ],
            "expectedResults": "For single keystrokes that use `-`, `+`, or `^`, a single `kbd` element should be created. For compound-keystrokes, the algorithm should differentiate between `-`, `+`, and `^` characters appearing in separator vs keystroke positions.",
            "actualResults": "The `-`, `+`, and `^` characters are treated as separators with two 'blank' keystrokes around them, leading to incorrect HTML output.",
            "supplementaryImages": [
                "A screenshot of the incorrect HTML output for the compound keystrokes."
            ],
            "additionalNotes": "The environment includes Windows OS, Python 3.9.1, Sphinx 3.4.0, and no specific Sphinx extensions or extra tools."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-8638",
        "structure_problem": {
            "problemSummary": "When using Sphinx's autodoc feature, instance variables in a class are automatically linked to other variables of the same name in the project, even if they are in different subpackages or classes, which can lead to misleading documentation.",
            "context": "This issue occurs with Sphinx version 1.8.3 and involves the autodoc extension. The automatic linking of variables with the same name can cause unrelated variables to be linked together, which is problematic when expecting each variable to be documented independently.",
            "stepsToReproduce": [
                "Clone the repository: git clone https://github.com/13steinj/sphinx-issue-examples",
                "Navigate to the demo issue branch: cd sphinx-issue-examples; git checkout referenced_variables",
                "Enter the docs directory: cd docs",
                "Generate HTML documentation: make html",
                "Serve the documentation locally: cd _build/html && python -m SimpleHTTPServer 8008",
                "View the documentation in a browser at 127.0.0.1:8008"
            ],
            "expectedResults": "Class variables should not be auto-linked to other variables with the same name, as they are typically unrelated and should be documented independently.",
            "actualResults": "Class variables are auto-linked to other variables with the same name, which can lead to misleading documentation.",
            "supplementaryImages": [
                "Screenshots from the private codebase showing the auto-linking issue."
            ],
            "additionalNotes": "The issue is independent of the OS and Python version but is relevant to Sphinx version 1.8.3 and the autodoc, intersphinx, todo, viewcode, and githubpages extensions."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-8658",
        "structure_problem": {
            "problemSummary": "The `napoleon_custom_sections` option in Sphinx does not allow for consistent styling of custom docstring sections like 'Side Effects' to match the style of other sections such as 'Parameters'.",
            "context": "The user wants to customize the display of custom docstring sections so that they have the same styling as other sections like 'Parameters', but still retain their custom names.",
            "additionalNotes": "The user has proposed potential solutions including setting `napoleon_custom_sections` with a tuple that includes a display style, or setting `napoleon_custom_sections` with a section name and disabling the default behavior to rename sections. The user is willing to contribute a PR for this feature and has linked to related GitHub issues for reference."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9230",
        "structure_problem": {
            "problemSummary": "Documentation rendering issue with dict(str, str) parameter in Sphinx",
            "context": "The parameter `opc_meta` defined as `:param dict(str, str) opc_meta: (optional)` in a docstring is being incorrectly rendered in the generated documentation as `str) opc_meta (dict(str,) â(optional)` instead of `opc_meta (dict(str,str)) â (optional)`. This issue occurs on Mac with Python 3.9.0, Sphinx 4.0.1, and specific Sphinx extensions.",
            "expectedResults": "The parameter should be rendered in the generated docs as `opc_meta (dict(str,str)) â (optional)`.",
            "actualResults": "The parameter is incorrectly rendered as `str) opc_meta (dict(str,) â(optional)`.",
            "supplementaryImages": [
                "Screenshots of the incorrect documentation rendering"
            ],
            "additionalNotes": "The issue is reported using a zip file named `sphinxTest.zip` which contains the test project."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9289",
        "structure_problem": {
            "problemSummary": "The `python_use_unqualified_type_names` configuration does not work on function descriptions when combined with `autodoc_typehints='description'`, resulting in unshortened type names even though links are created.",
            "context": "This issue was observed in a minimal project using Sphinx 4.0.2 on Python 3.9.",
            "stepsToReproduce": [
                "Create a minimal project with Sphinx 4.0.2 on Python 3.9.",
                "Add the `python_use_unqualified_type_names` and `autodoc_typehints='description'` configurations in `conf.py`.",
                "Define classes with type annotations in `package.py`.",
                "Build the documentation using Sphinx."
            ],
            "expectedResults": "The type names should be shortened to 'A' like it is when `autodoc_typehints='signature'`.",
            "actualResults": "The type names are not shortened even though links are created.",
            "supplementaryImages": [
                "Documentation screenshot showing unshortened type names."
            ],
            "additionalNotes": "This issue may be related to a specific configuration or version of Sphinx and Python."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9320",
        "structure_problem": {
            "problemSummary": "When attempting to run `sphinx-quickstart` in a directory that already contains a `conf.py` file, the utility prompts for a new root path but does not exit even after pressing Enter. The user expects the utility to exit after pressing Enter, but it instead prompts for a valid path name.",
            "context": "The issue occurs when trying to initialize a new Sphinx project in a directory that already has a `conf.py` file, which is a configuration file for Sphinx projects.",
            "stepsToReproduce": [
                "Navigate to a directory containing a `conf.py` file.",
                "Run `sphinx-quickstart`.",
                "Observe the prompt asking to enter a new root path or to exit by pressing Enter."
            ],
            "expectedResults": "The utility should exit after pressing Enter.",
            "actualResults": "The utility prompts for a valid path name instead of exiting.",
            "supplementaryImages": [
                "A screenshot showing the initial prompt and the error message after pressing Enter."
            ],
            "additionalNotes": "The environment is Ubuntu 20.04 with Python 3.8.5 and Sphinx 3.2.1."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9350",
        "structure_problem": {
            "problemSummary": "Man page rendering issue with :samp: directive in braces - font doesn't reset after the closure of the samp tag.",
            "context": "The problem occurs when using the :samp: directive with braces, causing the font change to carry over to subsequent lines until encountered by certain 'resetting' elements like bullets or headings.",
            "stepsToReproduce": [
                "Create a man page with :samp: directive including braces",
                "Observe the font continuation after the :samp: directive closure"
            ],
            "expectedResults": "The font should reset after the closure of the :samp: directive.",
            "actualResults": "The font change continues onto subsequent lines until encountering certain 'resetting' elements.",
            "supplementaryImages": [
                "Man page screenshot showing the issue"
            ],
            "additionalNotes": "HTML and LaTeX (PDF) formats are not affected by this issue."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9464",
        "structure_problem": {
            "problemSummary": "PEP 585 type hints are not rendered correctly in Sphinx documentation.",
            "context": "When using a PEP 585 generic as an annotation (e.g., `list[str]`), Sphinx's autodoc renders the annotation as `list` instead of `list[str]`. This behavior differs from using `typing.List[str]`, which renders as expected.",
            "stepsToReproduce": [
                "Define a function with a PEP 585 type hint: `def foo() -> list[str]: ...`",
                "Document the function using Sphinx's autodoc: `.. autofunction:: foo`"
            ],
            "expectedResults": "The annotation `list[str]` should be rendered as `list[str]` in the documentation.",
            "actualResults": "The annotation is rendered as `list` instead of `list[str]`.",
            "supplementaryImages": [
                "A screenshot of the incorrect documentation rendering."
            ],
            "additionalNotes": "A fix for this issue involves checking if the annotation has `__args__` and returning `repr(annotation)` if it does."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9673",
        "structure_problem": {
            "problemSummary": "The documentation generated using Napoleon and the specified configuration options is missing the return type information.",
            "context": "The user was trying to use the config option `autodoc_typehints_description_target = \"documented\"` combined with the Napoleon plugin (using Google style) to generate documentation for a function with a specific docstring structure.",
            "stepsToReproduce": [
                "Set the configuration options in Sphinx to use Napoleon and specify the `autodoc_typehints_description_target` option.",
                "Generate the documentation for a function with a docstring that includes parameters and a return section.",
                "Observe that the return type information is missing from the generated documentation."
            ],
            "expectedResults": "The documentation should include the return type information as specified in the docstring.",
            "actualResults": "The return type information is missing from the documentation.",
            "supplementaryImages": [
                "Screenshots showing the configuration settings and the missing return type in the generated documentation."
            ],
            "additionalNotes": "The user's project is Tuxemon, and the issue was encountered on Windows using Python 3.8 and Sphinx version 4.2.0."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9698",
        "structure_problem": {
            "problemSummary": "An index entry with parentheses was registered for `py:method` directive with `:property:` option where it should not have parentheses.",
            "context": "",
            "stepsToReproduce": [
                "Create a Sphinx document with the following content:",
                "```rst",
                "# index.rst",
                "",
                ".. py:method:: Foo.bar",
                "   :property:",
                "",
                ".. py:property:: Foo.baz",
                "```"
            ],
            "expectedResults": "An index entry for the property should not have parentheses.",
            "actualResults": "An index entry with parentheses was registered for `py:method` directive with `:property:` option.",
            "supplementaryImages": [
                {
                    "description": "Screenshot of the generated index showing the incorrect parentheses for the property entry."
                }
            ],
            "additionalNotes": "This issue occurs on a Mac with Python version 3.9.6 and Sphinx version HEAD of 4.x."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9797",
        "structure_problem": {
            "problemSummary": "Documentation for a classmethod in a parent class is not inherited by the method re-defined (without documentation) in a child class.",
            "context": "The issue is observed in a Python project with Sphinx documentation. The parent class has a classmethod with a docstring, but the child class redefines the method without a docstring, and the documentation is not inherited.",
            "stepsToReproduce": [
                "Create a Python module with a parent class that has a classmethod with a docstring.",
                "Create a child class that inherits from the parent class and redefines the classmethod without a docstring.",
                "Configure Sphinx to document the module.",
                "Build the documentation."
            ],
            "expectedResults": "The overridden classmethod should inherit documentation from the parent class.",
            "actualResults": "The overridden classmethod does not inherit documentation from the parent class.",
            "supplementaryImages": [
                "Screenshots showing the documentation build results."
            ],
            "additionalNotes": "The issue is observed in a specific project, and the Python version is 3.8. The Sphinx version is 4.2.0, and the extension used is sphinx.ext.autodoc."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9982",
        "structure_problem": {
            "problemSummary": "Different types of warnings in Sphinx documentation generation are displayed in different colors, though all warnings should have the same color according to the documentation.",
            "context": "The issue occurs when generating HTML documentation with Sphinx, specifically in the dockstore-documentation project.",
            "stepsToReproduce": [
                "Clone the dockstore-documentation repository.",
                "Checkout the 'make-html-warnings' branch.",
                "Install the required packages.",
                "Navigate to the 'docs' directory.",
                "Run 'make html'."
            ],
            "expectedResults": "All warnings should have the same color, consistent with the Sphinx documentation.",
            "actualResults": "Different types of warnings, such as image and transition warnings, are displayed in different colors.",
            "supplementaryImages": [
                "A screenshot of the warnings with different colors."
            ],
            "additionalNotes": "The issue is observed on macOS 10.15.7 with Python 3.7 and Sphinx v4.1.2."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9987",
        "structure_problem": {
            "problemSummary": "Position-only parameters in `__init__` prevent docstrings for attributes from being parsed.",
            "context": "The issue occurs when using position-only parameters in Python functions, including `__init__`, which stops inline, before, and after docstrings from being parsed.",
            "stepsToReproduce": [
                "Clone the GitHub repository: https://github.com/bryanforbes/sphinx-positional-only-issue",
                "Navigate to the repository directory: `cd sphinx-positional-only-issue`",
                "Install dependencies: `pip install -r requirements.txt`",
                "Navigate to the docs directory: `cd docs`",
                "Build the documentation: `make html`",
                "Open the HTML documentation: `open _build/html/index.html`"
            ],
            "expectedResults": "Both classes `test.WithPositional` and `test.WithoutPositional` should have the `a` property documented.",
            "actualResults": "Only `test.WithoutPositional` has the `a` property documented.",
            "supplementaryImages": [
                "Screenshots showing that only `test.WithoutPositional` has the `a` property documented."
            ],
            "additionalNotes": "The issue is encountered on macOS 11.6.1 with Python 3.10 and Sphinx 4.3.1. The Sphinx extensions used are sphinx.ext.autodoc and sphinx.ext.napoleon."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9997",
        "structure_problem": {
            "problemSummary": "Autodoc typehints do not create links for parametrized types.",
            "context": "The issue arises when using autodoc typehints with parametrized types, such as `Literal`, which do not generate a link to the hinted type in the documentation.",
            "stepsToReproduce": [
                "Create a Python file named `project.py` containing the provided code snippet.",
                "Use `sphinx-apidoc` to generate the documentation, including the `intersphinx` and `autodoc` extensions.",
                "Build the HTML documentation and open the `project.html` file."
            ],
            "expectedResults": "The `Literal` type in the parameter description should link to `typing.Literal` in CPython's documentation, similar to how `int` links to its documentation.",
            "actualResults": "The `Literal` type does not create a link to `typing.Literal` in the documentation.",
            "supplementaryImages": [
                "A screenshot showing the documentation where the `Literal` type does not link to `typing.Literal`."
            ],
            "additionalNotes": "The environment includes Linux OS, Python 3.9.4, Sphinx 4.0.0, and the `intersphinx` and `autodoc` extensions. No extra tools are required."
        }
    },
    {
        "instance_id": "sphinx-doc__sphinx-9999",
        "structure_problem": {
            "problemSummary": "The LaTeX output of a glossary in Sphinx documentation does not separate terms by a newline, causing too much vertical whitespace.",
            "context": "The issue occurs when using a glossary with sorted terms in Sphinx documentation. The expected behavior is that each term is separated by a newline in the LaTeX output, but this is not the case.",
            "stepsToReproduce": [
                "Create a glossary in Sphinx documentation with sorted terms.",
                "Build the documentation using `make latexpdf`.",
                "Observe the LaTeX output for the glossary."
            ],
            "expectedResults": "Each term in the glossary should be separated by a newline in the LaTeX output.",
            "actualResults": "Terms in the glossary are not separated by a newline, causing too much vertical whitespace.",
            "supplementaryImages": [],
            "additionalNotes": "The issue was observed on a Mac with Python 3.8.0 and Sphinx version 4.3.2."
        }
    },
    {
        "instance_id": "sympy__sympy-11787",
        "structure_problem": {
            "problemSummary": "The nsolve function is providing an incorrect result for the root of a given function. The root should be around 0.7, but the function is returning a value close to 1.",
            "context": "The issue arises when trying to find the root of a complex function using the nsolve function.",
            "stepsToReproduce": [
                "Define the function E and the variable t.",
                "Use the nsolve function to find the root of the derivative of E with respect to t, starting from an initial guess of 0.9."
            ],
            "expectedResults": "The root of the function should be around 0.7.",
            "actualResults": "The nsolve function returns a root close to 1.",
            "supplementaryImages": [
                "A plot of the function showing the expected root around 0.7."
            ],
            "additionalNotes": "The function E is complex and involves exponential and rational terms."
        }
    },
    {
        "instance_id": "sympy__sympy-11788",
        "structure_problem": {
            "problemSummary": "The singularity function powers are not printing correctly in the qtconsole when using SymPy's Beam module.",
            "context": "The user is using the SymPy library to solve for the reaction loads and loads of a beam under certain loads. The issue arises when the singularity function powers are outputted in the console, where they appear incorrectly.",
            "stepsToReproduce": [
                "Import necessary modules from SymPy.",
                "Define symbols for variables.",
                "Create a beam object with given parameters.",
                "Apply loads to the beam.",
                "Solve for reaction loads and display the loads."
            ],
            "expectedResults": "The singularity function powers should be displayed correctly in the console.",
            "actualResults": "The singularity function powers appear incorrectly in the console.",
            "additionalNotes": ""
        }
    },
    {
        "instance_id": "sympy__sympy-13264",
        "structure_problem": {
            "problemSummary": "The user is facing an issue with Sympy where the `simplify` function does not perform the ultimate simplification step when dealing with a particularly large expression. After applying `simplify` twice, the desired simplified result is achieved.",
            "context": "The user is using Sympy for computing Laplacian in different geometrical coordinate systems, which often results in very long expressions. The `simplify` function is generally effective, but in this specific case, it does not fully simplify the expression on the first attempt.",
            "stepsToReproduce": [
                "Create a Sympy expression with a large number of operations.",
                "Apply the `simplify` function once.",
                "Observe that the expression is partially simplified but not fully.",
                "Apply the `simplify` function again to achieve the desired level of simplification."
            ],
            "expectedResults": "The `simplify` function should perform the ultimate simplification step in a single call, yielding the most simplified form of the expression.",
            "actualResults": "The `simplify` function does not perform the ultimate simplification step in a single call, requiring a second application of `simplify` to achieve the desired result.",
            "supplementaryImages": [
                "A large expression before any simplification.",
                "A partially simplified expression after the first `simplify` call.",
                "A fully simplified expression after the second `simplify` call."
            ],
            "additionalNotes": "The user suggests that the order of simplification strategies in the `simplify` function may be causing the issue. They propose adding an optional recursive mode to the `simplify` function to potentially fix this problem."
        }
    },
    {
        "instance_id": "sympy__sympy-13840",
        "structure_problem": {
            "problemSummary": "The user is attempting to convert SymPy expressions containing Max and Min functions to JavaScript and R, but these conversions are not supported.",
            "context": "SymPy is a Python library for symbolic mathematics. The user is using SymPy to create expressions and then trying to convert these expressions to other programming languages.",
            "stepsToReproduce": [
                "Create a symbolic variable using SymPy.",
                "Use SymPy to create an expression with Max and Min functions.",
                "Attempt to convert the expression to JavaScript or R using SymPy's conversion functions."
            ],
            "expectedResults": "The user expected the SymPy expressions containing Max and Min functions to be converted to equivalent expressions in JavaScript and R.",
            "actualResults": "The conversion to JavaScript results in an error message indicating that Max is not supported. The conversion to R was not attempted or described.",
            "additionalNotes": "The issue may be related to the limitations of the SymPy library in handling conversions for certain functions to specific languages."
        }
    },
    {
        "instance_id": "sympy__sympy-15151",
        "structure_problem": {
            "problemSummary": "SymPy not pretty-printing indexed objects as expected.",
            "context": "The user is using SymPy to work with indexed symbols but the output is not as expected.",
            "stepsToReproduce": [
                "Import SymPy and initiate printing.",
                "Use the `Indexed` function with a symbol 'x1' and index 'i'."
            ],
            "expectedResults": "The user expected the indexed symbol to be pretty-printed as 'x_{1,i}'.",
            "actualResults": "The indexed symbol is printed as 'Indexed(x1, i)'.",
            "supplementaryImages": [
                "Image shows the code and the output where 'Indexed(x1, i)' is displayed instead of 'x_{1,i}'."
            ],
            "additionalNotes": "The user is unsure if this is expected behavior and is seeking clarification."
        }
    },
    {
        "instance_id": "sympy__sympy-15304",
        "structure_problem": {
            "problemSummary": "Issue with the Beam module in SymPy where applying a force with an order greater than 1 results in incorrect reaction loads.",
            "context": "The user is using the Beam module to analyze a beam under various loads. The issue arises when applying a force with an order greater than 1, leading to incorrect reaction loads.",
            "stepsToReproduce": [
                "Import necessary modules from SymPy",
                "Define symbols for elasticity (E), moment of inertia (I), reaction force (R), and reaction moment (M)",
                "Create a Beam object and apply boundary conditions for deflection and slope",
                "Apply loads to the beam, including a force with an order greater than 1",
                "Solve for reaction loads and observe the results"
            ],
            "expectedResults": "The reaction loads (R and M) should remain constant and correct regardless of the beam's length or the order of the applied force.",
            "actualResults": "The reaction load R does not remain constant and correct when changing the length of the beam or applying a force with an order greater than 1.",
            "supplementaryImages": [
                "Code snippet showing the setup and application of loads to the beam",
                "Graphical representation of the beam with applied loads"
            ],
            "additionalNotes": "The user suspects that the issue is related to the formation of the load equation, where higher-order compensations are not being taken into consideration."
        }
    },
    {
        "instance_id": "sympy__sympy-15976",
        "structure_problem": {
            "problemSummary": "A variable with a number, such as x1, is made invisible when printing in a MathML format.",
            "context": "The issue occurs when printing mathematical formulas using the sympy module in Python. The problem is that symbols ending with a number are not displayed correctly in MathML format.",
            "stepsToReproduce": [
                "Define symbols using sympy.symbols('x2 y z')",
                "Create a mathematical expression using the symbols, for example: y = x2*z + x2**3",
                "Print the expression using sympy.mathml(y, printer='presentation')",
                "Save the output to a file",
                "Open the file in a web browser to view the MathML"
            ],
            "expectedResults": "The symbol with a number should be displayed correctly in the MathML output.",
            "actualResults": "The symbol with a number is made invisible in the MathML output.",
            "supplementaryImages": [
                {
                    "description": "The MathML output when using a symbol with a number (e.g., x2)."
                },
                {
                    "description": "The MathML output when using a symbol without a number (e.g., x)."
                }
            ],
            "additionalNotes": "The issue was observed on a MacBook Pro running OS 10.14.2, using Sympy 1.3, Eclipse 2018-19, and Python 3.7."
        }
    },
    {
        "instance_id": "sympy__sympy-16003",
        "structure_problem": {
            "problemSummary": "The MathML presentation printing of multiple derivatives is messed up.",
            "context": "The current MathML presentation of the expression `Derivative(f(x, y, z), x, z, x, z, z, y)` looks incorrect and should be improved to match the LaTeX equivalent. The `_print_Derivative` method needs to be enhanced to print all derivative variables on a single line and to display the correct power in the numerator. It is also preferred that the actual function be on a separate line.",
            "expectedResults": "The MathML presentation should display all derivative variables on a single line and the correct power in the numerator, with the actual function on a separate line.",
            "actualResults": "The current MathML presentation does not display all derivative variables on a single line and does not show the correct power in the numerator.",
            "supplementaryImages": [
                "Images showing the current MathML presentation and the LaTeX equivalent."
            ],
            "additionalNotes": "The logic to group adjacent identical terms can be applied, as discussed in #15975."
        }
    },
    {
        "instance_id": "sympy__sympy-17067",
        "structure_problem": {
            "problemSummary": "The simplification of a trigonometric expression using SymPy returns an incorrect result.",
            "context": "The user has a complex trigonometric expression that they are trying to simplify using SymPy. After applying the `simplify` function, the result obtained is not correct according to the user's expectations and verification with Mathematica.",
            "stepsToReproduce": [
                "Define the symbols `alpha`, `beta`, and `gamma` using `symbols('alpha beta gamma')`.",
                "Define the expression `expr` as shown in the code snippet.",
                "Apply the `simplify` function to `expr`.",
                "The simplified result is `-2*cos(alpha)*cos(beta)/sin(2*beta)`, which is considered incorrect."
            ],
            "expectedResults": "The expected result is `-cos(alpha)*cot(beta)`, as verified by Mathematica and by direct calculation using trig identities.",
            "actualResults": "-2*cos(alpha)*cos(beta)/sin(2*beta)",
            "supplementaryImages": [
                "A screenshot of the SymPy live calculation showing the incorrect result."
            ],
            "additionalNotes": "The user has tried to reduce the expression to a smaller size but has not been able to reproduce the error with a smaller example. The issue has been observed in both SymPy version 1.3 and version 1.4."
        }
    },
    {
        "instance_id": "sympy__sympy-17115",
        "structure_problem": {
            "problemSummary": "An error occurs when attempting to define a Piecewise function with a condition involving a Boolean expression and an integer set in SymPy.",
            "context": "The issue is encountered when trying to create a Piecewise function with a condition that includes a Boolean expression and a set of integers. This causes a TypeError: Input args to Union must be Sets.",
            "stepsToReproduce": [
                "Define a symbol x.",
                "Create a condition cond using the And function with Le(x, 6), Ge(x, 1), and S.Integers.contains(x).",
                "Attempt to define a Piecewise function p2 with (S(1), cond) as the first condition and (S(0), True) as the default."
            ],
            "expectedResults": "The Piecewise function should be created successfully without any errors.",
            "actualResults": "A TypeError is raised stating that the input args to Union must be Sets.",
            "supplementaryImages": [
                "A screenshot of the SymPy Live environment showing the error message."
            ],
            "additionalNotes": "The issue appears to be related to the as_set() method not working correctly with Boolean expressions within Piecewise functions. The error is also observed on the SymPy Live environment. The user has provided a link to a GitHub pull request and mentions that others have reported the same issue."
        }
    },
    {
        "instance_id": "sympy__sympy-18922",
        "structure_problem": {
            "problemSummary": "The plot created using SymPy is incorrect when attempting to plot a constant line at y=3. The x-axis is incorrectly moved to y=3.",
            "context": "The user intends to plot a horizontal line at y=3 using SymPy's plotting functionality.",
            "stepsToReproduce": [
                "Import SymPy's plot function.",
                "Call `plot(3)` to attempt to plot a constant line at y=3."
            ],
            "expectedResults": "The plot should display a horizontal line at y=3 with the x-axis correctly labeled.",
            "actualResults": "The plot incorrectly displays the x-axis at y=3 instead of creating a horizontal line.",
            "supplementaryImages": [
                "Screenshot of the incorrect plot showing the x-axis moved to y=3."
            ],
            "additionalNotes": "The user may require assistance in understanding how to correctly plot a constant line in SymPy or a potential bug in the plotting functionality."
        }
    },
    {
        "instance_id": "sympy__sympy-21769",
        "structure_problem": {
            "problemSummary": "The LaTeX representation of a squared Clebsch-Gordan coefficient (`CG`) does not render correctly in Jupyter notebooks.",
            "context": "The issue was encountered with Sympy version 1.7.1 using Jupyter notebooks. The LaTeX string produced by the `latex()` function appears to be valid but does not render as expected.",
            "stepsToReproduce": [
                "Import the `CG` function from `sympy.physics.quantum.cg`.",
                "Create a `CG` object with specific parameters.",
                "Square the `CG` object using `** 2`.",
                "Observe that the LaTeX rendering does not show the squared coefficient correctly."
            ],
            "expectedResults": "The LaTeX representation of the squared `CG` object should render correctly, showing the squared coefficient.",
            "actualResults": "The LaTeX representation of the squared `CG` object does not render correctly, instead showing a different format.",
            "supplementaryImages": [
                "Images showing the code snippet and the incorrect LaTeX rendering."
            ],
            "additionalNotes": "A suggested fix involves wrapping the string in braces within the `CG` function to ensure proper LaTeX rendering."
        }
    },
    {
        "instance_id": "plotly__plotly.py-4083",
        "structure_problem": {
            "problemSummary": "Error occurs when attempting to map the 'most_similar_kt' column to hover_data in a Plotly Express scatter plot.",
            "context": "The user is working with a dataset that includes columns such as 'x', 'y', 'label', 'freq', 'similarity', 'size', 'class', and 'most_similar_kt'. They are trying to create a scatter plot using Plotly Express and want to include 'most_similar_kt' column in the hover_data.",
            "stepsToReproduce": [
                "Display the dataset using df.head() to confirm the presence of 'most_similar_kt' column.",
                "Attempt to create a scatter plot with the following code: fig = px.scatter(df, x='x',y='y', color='similarity', size='size', symbol='class',hover_name='label', hover_data='most_similar_kt', width=1500, height=1000, template='plotly_dark', render_mode='webgl')",
                "Observe the ValueError: Element of value of 'hover_data' is not the name of a column in 'data_frame'. Expected one of ['x', 'y', 'label', 'freq', 'similarity', 'size', 'class', 'most_similar_kt'] but received: m"
            ],
            "expectedResults": "The scatter plot should display correctly with 'most_similar_kt' column data shown in the hover information.",
            "actualResults": "The scatter plot fails to render due to a ValueError.",
            "supplementaryImages": [
                "An image of the dataset showing the 'most_similar_kt' column.",
                "An image of the incorrect scatter plot with the error message."
            ],
            "additionalNotes": "The issue seems to be related to the type of data passed to the 'hover_data' parameter. It is suggested that the user should pass a list of column names instead of a single column name."
        }
    },
    {
        "instance_id": "plotly__plotly.py-2600",
        "structure_problem": {
            "problemSummary": "The range_y parameter in the plotly code snippet appears to affect the marginals on the plot, which is unexpected.",
            "context": "The user is using plotly to create a scatter plot with marginal histograms. The y-axis of the scatter plot is set to a specific range (0-30), but this is causing the marginal histograms to be affected.",
            "stepsToReproduce": [
                "Use plotly to create a scatter plot with marginal histograms.",
                "Set the y-axis range using the range_y parameter in the .scatter() method.",
                "Observe that the marginal histograms are affected by the y-axis range."
            ],
            "expectedResults": "The range_y parameter should not affect the marginal histograms.",
            "actualResults": "The marginal histograms are affected by the y-axis range.",
            "supplementaryImages": [
                "A scatter plot with marginal histograms showing the effect of the range_y parameter."
            ],
            "additionalNotes": "The user has noted that the range_y parameter should not impact the marginals, but it appears to do so in this case."
        }
    },
    {
        "instance_id": "plotly__plotly.py-2591",
        "structure_problem": {
            "problemSummary": "Sunburst chart color issue where the sector color is the sum instead of the average of its children's values.",
            "context": "Reported by a user on the Plotly community forum.",
            "stepsToReproduce": [
                "Import plotly.express and numpy.",
                "Query the gapminder dataset for the year 2007.",
                "Create a sunburst chart using the queried data with 'continent' and 'country' as path, 'lifeExp' as values, and 'lifeExp' as color.",
                "Set the color_continuous_scale to 'RdBu'.",
                "Display the chart."
            ],
            "expectedResults": "The color of each sector should represent the average life expectancy of its children.",
            "actualResults": "The color of each sector represents the sum of the life expectancy values of its children instead of the average.",
            "supplementaryImages": [
                "A sunburst chart showing the issue with sector colors."
            ],
            "additionalNotes": "The issue is evident in the sunburst chart where the color gradient does not accurately represent the average life expectancy as expected."
        }
    },
    {
        "instance_id": "plotly__plotly.py-1966",
        "structure_problem": {
            "problemSummary": "Facet labels in a scatter plot do not respect the labels kwarg.",
            "context": "The issue occurs when attempting to customize facet labels in a scatter plot using plotly_express.",
            "stepsToReproduce": [
                "Create a scatter plot with `px.scatter`.",
                "Use `facet_row` and `facet_col` to specify the facets.",
                "Use the `labels` parameter to specify custom labels for the facets.",
                "Observe that the facet labels do not change to the custom labels."
            ],
            "expectedResults": "Facet labels should reflect the custom labels specified in the `labels` parameter.",
            "actualResults": "Facet labels do not change and display the default labels.",
            "supplementaryImages": [
                "The scatter plot shows facets labeled by days and times without custom labels."
            ],
            "additionalNotes": "This issue was reported in a GitHub pull request at https://github.com/plotly/plotly_express/pull/164."
        }
    },
    {
        "instance_id": "networkx__networkx-6503",
        "structure_problem": {
            "problemSummary": "The join operation in NetworkX trees does not include the original labels of inputs, and it does not handle cases where a label_attribute is passed as an argument. There is also a need to improve test coverage for operations.py (join).",
            "context": "The issue arises when using the `join` function from NetworkX to combine trees. The function does not properly handle the original labels of the input trees and does not consider the label_attribute argument. This results in missing or incorrect labels in the resulting graph. Additionally, there is room for improvement in the test coverage for this operation.",
            "stepsToReproduce": [
                "Create two full r-ary trees using `nx.full_rary_tree(r, n)`.",
                "Join the trees using `nx.join(trees)`.",
                "Attempt to join the trees with a specified label_attribute."
            ],
            "expectedResults": "The join operation should include the original labels of the input trees and correctly handle the label_attribute argument.",
            "actualResults": "The join operation does not include the original labels and raises an error when the label_attribute is specified.",
            "supplementaryImages": [
                "Code snippet showing the join operation with and without label_attribute."
            ],
            "additionalNotes": "The user has observed that the join function works for graphs as well as trees, and has requested clarification on whether the function is intended for trees or can also be used for general graphs."
        }
    },
    {
        "instance_id": "networkx__networkx-6098",
        "structure_problem": {
            "problemSummary": "The `connectionstyle` argument of `nx.draw_networkx_edges()` does not work properly for MultiGraphs and Undirected graphs.",
            "context": "The issue is observed when attempting to draw edges with a specific style in a MultiGraph or Undirected graph using NetworkX.",
            "stepsToReproduce": [
                "Create a MultiGraph or Undirected graph using NetworkX.",
                "Use the `nx.draw_networkx_edges()` function with the `connectionstyle` argument set to a specific style.",
                "Observe that the edges are not drawn with the specified style."
            ],
            "expectedResults": "The edges should be drawn with the specified connection style.",
            "actualResults": "The edges are not drawn with the specified connection style.",
            "supplementaryImages": [
                "The first image shows the expected output when drawing edges with a specific style in a direct graph.",
                "The second image shows the actual output when attempting to draw edges with the same style in a MultiGraph or Undirected graph."
            ],
            "additionalNotes": "This issue may affect the visualization of complex network structures in NetworkX."
        }
    },
    {
        "instance_id": "networkx__networkx-5616",
        "structure_problem": {
            "problemSummary": "Inconsistent implementation of Euler algorithms regarding connectedness.",
            "context": "The issue arises from a discrepancy between the docstring and the source code regarding the connectedness requirement for Euler paths in undirected graphs.",
            "stepsToReproduce": [
                "Create a directed graph with isolated nodes.",
                "Use `nx.has_eulerian_path(G)` to check for an Eulerian path.",
                "Observe that the method returns `True`.",
                "Create an undirected graph with isolated nodes.",
                "Use `nx.has_eulerian_path(G)` to check for an Eulerian path.",
                "Observe that the method returns `False`."
            ],
            "expectedResults": "Both directed and undirected graphs with isolated nodes should either both allow or disallow Eulerian paths based on the same criteria.",
            "actualResults": "Directed graphs with isolated nodes allow Eulerian paths, while undirected graphs with isolated nodes do not.",
            "supplementaryImages": [
                "A directed graph with isolated nodes.",
                "An undirected graph with isolated nodes."
            ],
            "additionalNotes": "The `is_eulerian` method consistently requires connectedness for both graph types."
        }
    },
    {
        "instance_id": "networkx__networkx-5354",
        "structure_problem": {
            "problemSummary": "Spiral layout with equidistant=True does not enforce equidistance for the first node.",
            "context": "The issue occurs with the spiral_layout function in NetworkX when the equidistant parameter is set to True. The expected behavior is for all nodes to be equidistant from one another, but the implementation results in the first node being treated differently.",
            "stepsToReproduce": [
                "Create a path graph with 5 nodes using nx.path_graph(5).",
                "Draw the graph using nx.draw(G, pos=nx.spiral_layout(G, equidistant=True))."
            ],
            "expectedResults": "All nodes should be equidistant from one another, including the first node.",
            "actualResults": "The first node is not equidistant from its neighbor.",
            "supplementaryImages": [
                "A graph with nodes laid out in a spiral pattern, showing the first node not being equidistant from its neighbor."
            ],
            "additionalNotes": "The spiral_layout function was added in issue #3534."
        }
    },
    {
        "instance_id": "networkx__networkx-5058",
        "structure_problem": {
            "problemSummary": "Failed to save graph generated using stochastic_block_model",
            "context": "Saving a graph that has been generated with a stochastic_block_model is not possible using write_graphml.",
            "stepsToReproduce": [
                "import networkx as nx",
                "wg = 0.8 # can be any number representing within group probability",
                "bg = 0.2 # can be any number representing between group probability",
                "community_probs = [[wg, bg, bg], [bg, wg, bg], [bg, bg, wg]]",
                "community_sizes = [10,10,10]",
                "G = nx.stochastic_block_model(community_sizes, community_probs)",
                "nx.write_graphml(G, 'file_name.graphml')"
            ],
            "expectedResults": "Expected to be able to export the generated graph using write_graphml.",
            "actualResults": "Received a KeyError when attempting to save the graph.",
            "additionalNotes": "Python version: 3.9.6, NetworkX version: 2.6.2"
        }
    },
    {
        "instance_id": "networkx__networkx-4378",
        "structure_problem": {
            "problemSummary": "The behavior of the `nodelist` keyword argument in `draw_networkx_edges` is not well-defined and does not match the user's expectation.",
            "context": "The user expects that any edges incident on a node not in the `nodelist` should not be drawn. However, the `nodelist` currently only affects the size of the nodes in the visualization.",
            "stepsToReproduce": [
                "Create a path graph with 3 nodes.",
                "Define positions for the nodes.",
                "Use `draw_networkx_nodes` with `nodelist` set to [0, 1].",
                "Use `draw_networkx_edges` with `nodelist` set to [0, 1]."
            ],
            "expectedResults": "The edge (1, 2) should not be drawn because node 2 is not in the `nodelist`.",
            "actualResults": "The edge (1, 2) is drawn despite node 2 not being in the `nodelist`.",
            "supplementaryImages": [
                "An image showing the expected result without the edge (1, 2).",
                "An image showing the actual result with the edge (1, 2) drawn."
            ],
            "additionalNotes": "The `nodelist` parameter needs to be added to the docstring and its behavior tested. The question about the desired behavior is raised to clarify and implement the correct functionality."
        }
    },
    {
        "instance_id": "networkx__networkx-3764",
        "structure_problem": {
            "problemSummary": "The shell radius is too big for shells of 1 element, causing them to have an X position equal to their location +1 in nlist.",
            "context": "This issue is the opposite of issue #3188, where shells of one element collapsed to zero radius.",
            "stepsToReproduce": [
                "Create a list of nodes with various elements.",
                "Apply the shell layout algorithm to the list of nodes.",
                "Observe the X position of shells with one element."
            ],
            "expectedResults": "Shells with one element should not have an X position equal to their location +1 in nlist.",
            "actualResults": "Shells with one element have an X position equal to their location +1 in nlist.",
            "supplementaryImages": [
                "A visual representation of the issue showing a distorted layout."
            ],
            "additionalNotes": "The issue affects the layout of nodes in network visualization, potentially distorting the representation of the network structure."
        }
    },
    {
        "instance_id": "vega__altair-2785",
        "structure_problem": {
            "problemSummary": "Request to change the default chart dimensions in Altair to have an equal aspect ratio for better comparison of data distribution between variables.",
            "context": "The current default theme in Altair specifies an aspect ratio of 4/3 with a width of 400 and a height of 300 for continuous data. The default in Vega-Lite is to make both dimensions of equal length, which is perceived as beneficial for fair comparison of data distribution.",
            "stepsToReproduce": [
                "Create a chart using Altair with default settings."
            ],
            "expectedResults": "Charts with an equal aspect ratio for better comparison of data distribution.",
            "actualResults": "Charts with an aspect ratio of 4/3, which may affect the fair comparison of data distribution.",
            "supplementaryImages": [
                "Charts comparing miles per gallon to horsepower with different aspect ratios."
            ],
            "additionalNotes": "The suggestion is to change the default width in Altair to 300 px, making the X and Y axes occupy the same amount of pixels by default. There is a consideration whether having an unequal aspect ratio, like the current default, provides benefits by resembling the screen aspect ratio."
        }
    },
    {
        "instance_id": "vega__altair-1092",
        "structure_problem": {
            "problemSummary": "Altair 2.2 fails to recognize the 'format' property of the InlineData object when consolidate_datasets is enabled.",
            "context": "The issue arises when attempting to use Altair's InlineData with a specific data format. The code snippet provided demonstrates the expected behavior when 'consolidate_datasets' is disabled and the unexpected behavior when it is enabled.",
            "stepsToReproduce": [
                "Define a dataset using Altair's InlineData with a specified format property.",
                "Create a chart using the defined dataset.",
                "Enable 'consolidate_datasets'.",
                "Render the chart."
            ],
            "expectedResults": "The chart should render correctly with the specified data format.",
            "actualResults": "The chart does not render correctly when 'consolidate_datasets' is enabled.",
            "supplementaryImages": [
                "Image 1: Chart rendered correctly when 'consolidate_datasets' is disabled.",
                "Image 2: Chart rendered incorrectly when 'consolidate_datasets' is enabled."
            ],
            "additionalNotes": "The issue appears to be related to the 'type' and 'property' attributes of the 'format' property in the InlineData object."
        }
    },
    {
        "instance_id": "vega__altair-830",
        "structure_problem": {
            "problemSummary": "The issue involves updating the `encode()` method in Altair to support multiple encoding fields in tooltips, as demonstrated in a recent vega-lite release.",
            "context": "The current Altair API does not allow passing multiple fields to the tooltip encoding in a simplified manner. The example provided shows how to achieve this in vega-lite, which Altair should support.",
            "stepsToReproduce": [
                "Create a chart using Altair with existing data.",
                "Attempt to use the tooltip encoding with multiple fields in a simplified API format."
            ],
            "expectedResults": "The tooltip should display the multiple fields specified in the simplified API format.",
            "actualResults": "The tooltip does not display multiple fields as expected.",
            "supplementaryImages": [
                "A chart displaying car data with a tooltip for a Datsun 280-zx, showing the current tooltip behavior."
            ],
            "additionalNotes": "The issue is related to the API design in Altair and how it handles tooltip encodings with multiple fields."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-27754",
        "structure_problem": {
            "problemSummary": "3D arrow head color does not match arrow body color in matplotlib plot",
            "context": "The issue occurs when attempting to plot 3D arrows with a color gradient that is not uniformly applied to the arrow head.",
            "stepsToReproduce": [
                "Import necessary libraries: numpy, matplotlib.pyplot, mpl_toolkits.mplot3d",
                "Create arrays for x, y, z, dx, dy, dz coordinates",
                "Normalize dy array for color mapping",
                "Create a 3D subplot using matplotlib",
                "Use quiver function to plot 3D arrows with a color gradient based on dy",
                "Set the y-axis limits",
                "Display the plot"
            ],
            "expectedResults": "The entire arrow should have a single color.",
            "actualResults": "The color of the 3D arrow head does not match that of the arrow body.",
            "supplementaryImages": [
                "Image showing the 3D plot with mismatched arrow colors"
            ],
            "additionalNotes": "This issue is specific to matplotlib version 2.2.2 and macOS 10.13.6. The user suspects it may be related to another issue (#11746)."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-26926",
        "structure_problem": {
            "problemSummary": "When using subfigures in matplotlib, legends called with `fig.legend()` are hidden behind the subfigure and axes backgrounds.",
            "context": "The issue occurs when setting the facecolor of the axes and subfigures to 'none'.",
            "stepsToReproduce": [
                "Create a figure with subfigures using `fig.subfigures(nrows=2, ncols=1)`. ",
                "Add subplots to each subfigure using `subfig.subplots(1, 2)`. ",
                "Plot data on each axis and set labels for the lines. ",
                "Set the facecolor of the axes and subfigures to 'none'.",
                "Call `fig.legend()` to add a legend to the figure.",
                "Save and display the figure."
            ],
            "expectedResults": "The legend should be visible on top of the subfigure and axes backgrounds.",
            "actualResults": "The legend is hidden behind the subfigure and axes backgrounds.",
            "supplementaryImages": [
                "Images showing the legend hidden behind the backgrounds.",
                "Images showing the legend visible when not using the 'none' facecolor."
            ],
            "additionalNotes": "This issue does not occur when using `ax.legend()` or `subfig.legend()`."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-26788",
        "structure_problem": {
            "problemSummary": "The axhline function does not draw a circle at a given radius on polar axes, and there is a need for a clear API to draw gridlines at a given x or y value for arbitrary axes.",
            "context": "The issue arises when attempting to draw a horizontal line at a constant radius on a polar plot using matplotlib's axhline function. The expected behavior is for the function to draw a circle at the specified radius, but it currently does not draw anything. This affects the usability of axhline for non-rectilinear axes.",
            "stepsToReproduce": [
                "Create a polar plot using matplotlib.",
                "Use axvline to draw a radial line at a given angle.",
                "Use axhline to attempt to draw a circle at a given radius."
            ],
            "expectedResults": "A circle should be drawn at the specified radius on the polar plot.",
            "actualResults": "No line is drawn when using axhline on a polar plot.",
            "supplementaryImages": [
                "A polar plot with a radial line drawn using axvline.",
                "A polar plot with an attempt to draw a circle using axhline, resulting in no visible change."
            ],
            "additionalNotes": "The issue can be resolved by explicitly setting the _interpolation_steps property of the axhline object, but this is not a user-friendly solution. There is a need for a clear and general API for drawing gridlines on arbitrary axes."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-26586",
        "structure_problem": {
            "problemSummary": "Modifying ticklabels in axisartist",
            "context": "The user is facing an issue with modifying ticklabels in Matplotlib's axisartist, unlike the mainline matplotlib where this can be done easily.",
            "expectedResults": "The user expected to be able to change the ticklabels in axisartist as they can with the mainline matplotlib.",
            "actualResults": "The user was unable to change the ticklabels in axisartist.",
            "supplementaryImages": [
                "The provided image is a plot with a reference line and correlation values on a curve, which does not directly relate to the issue of modifying ticklabels."
            ],
            "additionalNotes": "The user is seeking guidance on whether anyone has encountered this issue before and how it might be resolved."
        }
    },
    {
        "instance_id": "sympy__sympy-26941",
        "structure_problem": {
            "problemSummary": "The user is encountering a TypeError when attempting to substitute a series expansion of the cosine function into another cosine series expansion using SymPy in Python. The error occurs because the result of the substitution is not iterable, which is required for the operation to proceed.",
            "context": "The issue arises when working with SymPy, a Python library for symbolic mathematics, specifically when performing series expansions and substitutions on trigonometric functions.",
            "stepsToReproduce": [
                "Import the necessary SymPy functions.",
                "Attempt to substitute a series expansion of the cosine function into another cosine series expansion using the `subs` method.",
                "The error occurs at the substitution step."
            ],
            "expectedResults": "The user expected the substitution to work correctly without raising a TypeError.",
            "actualResults": "A TypeError was raised, indicating that the zip argument must support iteration.",
            "supplementaryImages": [
                "Screenshots of the code and error messages are provided, showing the exact context and error messages encountered during the process."
            ],
            "additionalNotes": "The user notes that the issue does not occur when performing a similar operation with the sine function."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-3458",
        "structure_problem": {
            "problemSummary": "The `scale(y=\"log\")` does not apply a log-scale to the axis in a `pair` plot in the next-gen interface of the seaborn library version 0.12.0b2.",
            "context": "The issue arises when attempting to use a logarithmic scale on a `pair` plot. This behavior contrasts with a single plot where the log-scaling works as expected.",
            "stepsToReproduce": [
                "Import seaborn as sns and seaborn.objects as so.",
                "Load the dataset using `sns.load_dataset('diamonds')`.",
                "Create a `Plot` object with the dataset and `x='carat'`.",
                "Use the `.pair(y=('price', 'price'))` method to specify the y-axis variables.",
                "Apply the `.scale(y='log')` method to set the y-axis to a logarithmic scale.",
                "Add a scatter plot using `.add(so.Scatter())`."
            ],
            "expectedResults": "The y-axis of the `pair` plot should be scaled logarithmically.",
            "actualResults": "The y-axis remains on a linear scale despite applying `.scale(y='log')`.",
            "supplementaryImages": [
                "Three scatter plots showing the distribution of carat and price data with different scales."
            ],
            "additionalNotes": "The issue is specific to the `pair` plot in the `objects` interface of seaborn version 0.12.0b2."
        }
    },
    {
        "instance_id": "mwaskom__seaborn-3454",
        "structure_problem": {
            "problemSummary": "The order of legend handles changes when labels are renamed in a histogram plot created with seaborn.",
            "context": "The issue occurs when renaming labels in the legend of a histogram plot. This workaround involves providing both handles and labels to `sns.move_legend`.",
            "stepsToReproduce": [
                "Create a histogram plot with seaborn using the `sns.histplot` function.",
                "Rename the labels in the legend using `ax.legend(['new_label1', 'new_label2', 'new_label3'])`.",
                "Observe the order of legend handles."
            ],
            "expectedResults": "The legend handles should maintain their original order despite the labels being renamed.",
            "actualResults": "The order of legend handles is reversed after renaming the labels.",
            "supplementaryImages": [
                "Three images showing the histogram plot with original and renamed labels, demonstrating the issue."
            ],
            "additionalNotes": "The workaround suggested involves providing both handles and labels to `sns.move_legend`. This issue was observed in seaborn version 11.2."
        }
    }
]