[
    {
        "instance_id": "astropy__astropy-11693",
        "structure_problem": {
            "problemSummary": "'WCS.all_world2pix' failed to converge when plotting WCS with non linear distortions",
            "stepsToReproduce": [
                "Create a WCS object with non-linear distortions using the Sip class.",
                "Plot an image with the WCS as projection using matplotlib.",
                "Add a grid to the plot."
            ],
            "expectedResults": "The plot should display the image with the grid correctly.",
            "actualResults": "The plot fails with a 'NoConvergence' error."
        }
    },
    {
        "instance_id": "astropy__astropy-13838",
        "structure_problem": {
            "problemSummary": "Printing tables doesn't work correctly with 0-length array cells",
            "stepsToReproduce": [
                "Create a list of dictionaries where each dictionary contains some items with an integer value and some of these items set the length for 1 or more array values.",
                "Create a Table using the `rows` attribute and feed to it the list of dictionaries.",
                "Try to print the table with only events that have null array data (but the rest of the fields have something to show)."
            ],
            "expectedResults": "The table should print fine also when there are only 'bad' events.",
            "actualResults": "An IndexError is thrown when trying to print the table with only events that have null array data."
        }
    },
    {
        "instance_id": "astropy__astropy-14295",
        "structure_problem": {
            "problemSummary": "The presence of SIP keywords in the FITS header causes astropy to ignore PV keywords, leading to unexpected behavior in the WCS solution.",
            "stepsToReproduce": [
                "Initialize the header with SIP and PV keywords.",
                "Parse the header using astropy.wcs.WCS.",
                "Plot the graticule.",
                "Remove the PV keywords and run again.",
                "Observe that the graticule remains unchanged."
            ],
            "expectedResults": "The astropy WCS solution should consider both SIP and PV keywords, resulting in a different graticule when PV keywords are present.",
            "actualResults": "The astropy WCS solution ignores PV keywords when SIP keywords are present, leading to an unchanged graticule regardless of the presence of PV keywords."
        }
    },
    {
        "instance_id": "astropy__astropy-8292",
        "structure_problem": {
            "problemSummary": "The implementation of the `littleh` equivalency in Astropy seems to be incorrect, as it does not correctly convert distances when using the `littleh` unit.",
            "stepsToReproduce": [
                "Import astropy.units as u.",
                "Set H0_70 = 70 * u.km/u.s / u.Mpc.",
                "Set distance = 100 * (u.Mpc/u.littleh).",
                "Convert distance to u.Mpc using u.with_H0(H0_70)."
            ],
            "expectedResults": "The distance should be converted to 140 Mpc when h=0.7.",
            "actualResults": "The distance is converted to 67.74 Mpc, which is incorrect."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-13908",
        "structure_problem": {
            "problemSummary": "Minor ticklabels are missing at positions of major ticks.",
            "codeForReproduction": "```python\nimport numpy as np\nimport matplotlib.dates as mdates\nimport matplotlib.pyplot as plt\n\n# Code for reproduction\n```",
            "actualOutcome": "The minor ticklabels showing the `00:00` hours are missing.",
            "expectedOutcome": "The expected outcome would be the same as when running the code with matplotlib 3.0.2 or below: I would expect to see the hours throughout.",
            "matplotlibVersion": "master",
            "matplotlibBackend": "any",
            "pythonVersion": "3.6",
            "operatingSystem": "Win8"
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-13980",
        "structure_problem": {
            "problemSummary": "Non-sensical negative radial scale minimum autoset in polar plot",
            "stepsToReproduce": [
                "Create a polar plot with a set of random data points.",
                "Observe the default bottom y_limit of the plot."
            ],
            "expectedResults": "The default bottom y_limit of the plot should be zero.",
            "actualResults": "The default bottom y_limit of the plot is not zero, resulting in a hole around the origin.",
            "additionalInformation": {
                "matplotlibVersion": "3.0.2",
                "operatingSystem": [
                    "Windows 10",
                    "Ubuntu Linux"
                ],
                "matplotlibBackend": "inline",
                "pythonVersion": [
                    "3.7",
                    "3.6"
                ],
                "jupyterVersion": "JupyterLab 0.35.4"
            }
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-13983",
        "structure_problem": {
            "problemSummary": "Removing a shared axes in a matplotlib plot prevents the remaining axes from using unit-provided formatters, leading to incorrect tick formatting.",
            "stepsToReproduce": [
                "Create a figure with two subplots sharing the x-axis.",
                "Remove one of the subplots using `axs[1].remove()`.",
                "Plot data on the remaining subplot.",
                "Observe the tick formatting on the remaining subplot."
            ],
            "expectedResults": "The remaining subplot should have correct tick formatting provided by the unit.",
            "actualResults": "The remaining subplot does not have correct tick formatting, as the call to `axs[1].remove()` prevented the axs[0] from acquiring the correct tick formatter and locator.",
            "additionalNotes": {
                "InterestingObservation": "Using `fig.delaxes(axs[1])` instead of `axs[1].remove()` does not exhibit the same bug.",
                "PossibleCause": "The issue seems to stem from the `_remove_ax` method in matplotlib, where the call to `set_major_formatter` (and similar methods) makes matplotlib believe that a user-provided formatter is in use, which should not be overridden by the unit framework."
            }
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-13984",
        "structure_problem": {
            "problemSummary": "Tick mark color cannot be set on Axes3D in matplotlib. The `ax.tick_params` method only changes the color of tick labels, not the tick marks themselves.",
            "stepsToReproduce": [
                "Create a 3D plot using `mpl_toolkits.mplot3d.Axes3D`.",
                "Use `ax.scatter` to plot points.",
                "Set the color of the axes lines using `ax.w_xaxis.line.set_color`, `ax.w_yaxis.line.set_color`, and `ax.w_zaxis.line.set_color`.",
                "Set the color of the axis labels using `ax.xaxis.label.set_color`, `ax.yaxis.label.set_color`, and `ax.zaxis.label.set_color`.",
                "Attempt to set the color of the tick marks using `ax.tick_params(axis='x', colors='red')`, `ax.tick_params(axis='y', colors='red')`, and `ax.tick_params(axis='z', colors='red')`."
            ],
            "expectedResults": "The tick marks on the 3D plot should change to the specified color.",
            "actualResults": "Only the tick labels change to the specified color, while the tick marks remain unchanged."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-14043",
        "structure_problem": {
            "problemSummary": "Bar plot error bars break when zorder is greater than 1.",
            "stepsToReproduce": "1. Create a figure and an axis using `plt.subplots(1,1)`. 2. Define x and y values for the bar plot. 3. Use `ax.bar` to create bar plots with different zorders. 4. Display the figure using `fig.show()`.",
            "expectedResults": "Error bars should be visible and correctly positioned for all bar plots regardless of their zorder.",
            "actualResults": "Error bars break when the zorder is greater than 1.",
            "matplotlibVersion": "2.2.3",
            "operatingSystem": "Arch Linux",
            "pythonVersion": "3.6",
            "jupyterVersion": "5.7.0",
            "condaDefaultChannel": true,
            "relatedIssue": "#1622"
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-14623",
        "structure_problem": {
            "problemSummary": "Inverting an axis using its limits does not work for log scale in matplotlib 3.1.0.",
            "stepsToReproduce": [
                "1. Import numpy and matplotlib.pyplot.",
                "2. Create a linearly spaced array 'y' from 1000e2 to 1.",
                "3. Create an array 'x' using np.exp(-np.linspace(0, 1, y.size)).",
                "4. Iterate over yscale options ('linear', 'log').",
                "5. For each yscale, create a figure and axis.",
                "6. Plot x against y on the axis.",
                "7. Set the yscale of the axis.",
                "8. Set the y-axis limits to be inverted (y.max(), y.min())."
            ],
            "expectedResults": "The y-axis should be inverted for both the 'linear' and 'log' scale.",
            "actualResults": "The y-axis is only inverted for the 'linear' scale, not for the 'log' scale."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-19763",
        "structure_problem": {
            "problemSummary": "Multicursor disappears when not moving on nbagg with useblit=False and burns CPU",
            "stepsToReproduce": [
                "Use nbagg backend",
                "Create a plot with multiple axes",
                "Add a MultiCursor widget to the plot",
                "Stop moving the mouse"
            ],
            "expectedResults": "Red line doesn't disappear and CPU usage remains stable",
            "actualResults": "Multicursor disappears when not moving and high CPU usage",
            "matplotlibVersion": "3.3.4.post2456+gfd23bb238",
            "backend": "nbagg",
            "pythonVersion": "3.9.1",
            "jupyterVersion": "Notebook 6.2.0 - IPython 7.20.0",
            "operatingSystem": "Ubuntu"
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-20470",
        "structure_problem": {
            "problemSummary": "Text objects with a 'label' keyword argument do not create handles or labels for the legend in Matplotlib.",
            "stepsToReproduce": [
                "1. Import matplotlib.pyplot as plt.",
                "2. Define x and y arrays with values [0, 10] and [0, 10] respectively.",
                "3. Create a figure and an axis using fig.add_subplot(1, 1, 1).",
                "4. Plot a line using ax.plot(x, y, label=\"line\").",
                "5. Add text to the plot using ax.text(x=2, y=5, s=\"text\", label=\"label\").",
                "6. Add a legend to the plot using ax.legend().",
                "7. Display the plot using plt.show()."
            ],
            "expectedResults": "A legend entry for the text object is expected to be created and displayed.",
            "actualResults": "No legend entry is created for the text object with a 'label' keyword argument.",
            "matplotlibVersion": "3.3.3"
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-20518",
        "structure_problem": {
            "problemSummary": "Calls to `set_sketch_params()` are ignored by the PGF backend and do not have any influence in the resulting pgf or pdf file.",
            "stepsToReproduce": "1. Import matplotlib and set the backend to 'pgf'. 2. Update matplotlib's rcParams with font family, text usetex, pgf rcfonts, and pgf preamble. 3. Create a figure and add a subplot. 4. Plot a range of numbers. 5. Set sketch parameters for the bottom spine of the subplot. 6. Save the figure as a pgf or pdf file.",
            "expectedResults": "The sketch parameters should be applied to the bottom spine of the subplot in the resulting pgf or pdf file.",
            "actualResults": "The sketch parameters are ignored by the PGF backend and do not have any influence in the resulting pgf or pdf file."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-20584",
        "structure_problem": {
            "problemSummary": "The issue is that after plotting with `contourf` and manipulating the lines, the result becomes coarser. Specifically, a simple `lc.set_segments(lc.get_segments())` operation causes the lines to appear coarser than expected.",
            "stepsToReproduce": [
                "Import necessary libraries: numpy and matplotlib.pyplot.",
                "Create a meshgrid using numpy.linspace for x and y.",
                "Calculate Z based on X and Y.",
                "Use plt.contour to plot the contour with a specific level.",
                "Retrieve the segments from the contour collection.",
                "Set the segments back to the contour collection.",
                "Set the aspect ratio of the plot to 'equal'.",
                "Display the plot."
            ],
            "expectedResults": "The lines should remain the same after the `lc.set_segments(lc.get_segments())` operation.",
            "actualResults": "The lines become coarser after the `lc.set_segments(lc.get_segments())` operation."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-20761",
        "structure_problem": {
            "problemSummary": "The position of a subfigure shifts lower on the y-axis when the 'x' keyword argument is used for supxlabel for that subfigure.",
            "stepsToReproduce": [
                "Create a figure with constrained layout and specified size.",
                "Create top and bottom subfigures with specified hspace and height ratios.",
                "Add subplots to the top and bottom-left subfigures.",
                "Add a gridspec to the bottom-left subfigure and add subplots to it.",
                "Set titles for the subplots.",
                "Use supxlabel with the 'x' keyword argument for the bottom-left subfigure.",
                "Add a subplot to the bottom-right subfigure and set its title.",
                "Use supxlabel for the bottom-right subfigure."
            ],
            "expectedResults": "The subfigure position should not change, and the supxlabel should shift to the right.",
            "actualResults": "The body of the subfigure shifts downward (lower on the y-axis) and covers the supxlabel."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-20826",
        "structure_problem": {
            "problemSummary": "When using shared axes in matplotlib and calling `ax.clear()`, extra ticks and tick labels appear that should be hidden, which is a behavior change between matplotlib 3.4.1 and 3.4.2.",
            "stepsToReproduce": [
                "Import numpy and matplotlib.pyplot.",
                "Create a figure with subplots using `plt.subplots(2, 2, sharex=True, sharey=True)`.",
                "Generate data for plotting.",
                "Iterate over the flattened axes and clear each axis, then plot the data."
            ],
            "expectedResults": "The plot should not show extra ticks and tick labels that should be hidden by virtue of the shared axes.",
            "actualResults": "The plot shows extra ticks and tick labels that should be hidden, and there are also ticks that appear along the top and right side of each subplot which are not part of the default plotting style."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-21443",
        "structure_problem": {
            "problemSummary": "When setting axes position with `ax = plt.axes(position = [...])`, the position data is not being incorporated, causing the axes to completely overlap instead of being separate.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot as plt.",
                "Create a figure.",
                "Define positions for two axes.",
                "Use `plt.axes(position = [...])` to create the first axis and plot a red line.",
                "Use `plt.axes(position = [...])` to create the second axis and plot a blue dashed line."
            ],
            "expectedResults": "Two separate axes with the specified positions.",
            "actualResults": "The two axes completely overlap.",
            "operatingSystem": "Windows",
            "matplotlibVersion": "3.4.2",
            "matplotlibBackend": "Qt5Agg",
            "pythonVersion": "3.8.8",
            "jupyterVersion": "No response",
            "otherLibraries": "No response",
            "installation": "conda",
            "condaChannel": "No response"
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-21490",
        "structure_problem": {
            "problemSummary": "Line2D does not copy its inputs, leading to potential unintended changes in the drawn line when the input arrays are modified in-place.",
            "stepsToReproduce": [
                "Create a line plot using Line2D with an array `t`.",
                "Save the plot.",
                "Modify the array `t` in-place.",
                "Save the plot again.",
                "Change the draw style of Line2D to trigger cache invalidation.",
                "Save the plot again."
            ],
            "expectedResults": "Modifying `t` a posteriori should not affect the Line2D.",
            "actualResults": "Modifying `t` a posteriori affects the Line2D, particularly the x array, but not the y array.",
            "operatingSystem": "Linux",
            "matplotlibVersion": "3.5b1",
            "matplotlibBackend": "mplcairo",
            "pythonVersion": "3.9",
            "installationMethod": "source"
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-21550",
        "structure_problem": {
            "problemSummary": "Display issue with matplotlib-3.5.0.dev2445+gb09aad279b",
            "stepsToReproduce": "1. Install matplotlib-3.5.0.dev2445+gb09aad279b using pip.\n2. Run the provided code snippet in a Jupyter notebook.\n3. Observe the display issue.",
            "expectedResults": "The display should work correctly as it does in matplotlib-3.4.3.",
            "actualResults": "The display is not working well when swapping matplotlib-3.4.3 with matplotlib-3.5.0.dev2445+gb09aad279b, with all other conditions being equal."
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-21568",
        "structure_problem": {
            "problemSummary": "The spacing for a datetime axis is unclear when using `usetex=True` in matplotlib version 3.4 compared to version 3.3.",
            "stepsToReproduce": [
                "Import matplotlib, matplotlib.pyplot, numpy, and pandas.",
                "Set the seed for numpy.",
                "Configure matplotlib to use TeX for text rendering.",
                "Generate a date range from '2020-01-01 00:00:00' to '2020-01-01 00:10:00' with 100 periods.",
                "Generate random data.",
                "Create a figure and axis with constrained layout.",
                "Plot the dates and data on the axis.",
                "Save the figure with the matplotlib version number."
            ],
            "expectedResults": "The spacing from version 3.3 should be maintained in a TeX format.",
            "actualResults": "The spacing for the datetime axis is unclear in matplotlib version 3.4 when using `usetex=True`.",
            "operatingSystem": "Windows",
            "matplotlibVersion": "3.4.3",
            "matplotlibBackend": "Not specified",
            "pythonVersion": "Not specified",
            "jupyterVersion": "Not specified",
            "otherLibraries": "Not specified",
            "installationMethod": "conda",
            "condaChannel": "conda-forge"
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-21617",
        "structure_problem": {
            "problemSummary": "Text sometimes is missing when figure saved to EPS",
            "stepsToReproduce": [
                "Create a testing environment with matplotlib=3.3.4 and matplotlib=3.4.3",
                "Use the provided code to generate EPS files with different gridline spacings",
                "Observe the presence or absence of the title '>>> do you see me <<<' in the EPS files"
            ],
            "expectedResults": "An EPS file with the title '>>> do you see me <<<' message when using matplotlib v3.3.4",
            "actualResults": "An EPS file with no '>>> do you see me <<<' message when using matplotlib v3.4.3",
            "operatingSystem": "Debian GNU/Linux bookworm, Linux Mint 20.2 Uma",
            "matplotlibVersion": "3.4.3",
            "matplotlibBackend": "Qt5Agg",
            "pythonVersion": "3.7.12",
            "jupyterVersion": "not used",
            "otherLibraries": "cartopy=0.18.0",
            "installationMethod": "conda",
            "condaChannel": "conda-forge"
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-22865",
        "structure_problem": {
            "problemSummary": "Colorbar with drawedges=True and extend='both' does not draw edges at extremities",
            "stepsToReproduce": "1. Import matplotlib, numpy, and matplotlib.pyplot.\n2. Create a custom colormap and normalize it with extend='both'.\n3. Create a figure and a subplot.\n4. Add a colorbar with drawedges=True to the subplot.\n5. Adjust the subplot layout and display the figure.",
            "expectedResults": "The colorbar should display black lines separating the colors, including at the extremities.",
            "actualResults": "The colorbar displays black lines separating the colors, but the lines at the extremities are missing.",
            "additionalInformation": {
                "OperatingSystem": "No response",
                "MatplotlibVersion": "3.5.1",
                "MatplotlibBackend": "No response",
                "PythonVersion": "No response",
                "JupyterVersion": "No response",
                "Installation": "No response"
            }
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-22871",
        "structure_problem": {
            "problemSummary": "ConciseDateFormatter not showing year anywhere when plotting <12 months",
            "stepsToReproduce": [
                "Create a time array from February 14, 2021, to August 10, 2021, with daily increments.",
                "Create a data array with values decreasing quadratically.",
                "Plot the data using matplotlib with ConciseDateFormatter for the x-axis.",
                "Observe the x-axis labels."
            ],
            "expectedResults": "The year '2021' should be displayed in the offset, to the right of the x-axis.",
            "actualResults": "The year '2021' is not displayed anywhere on the plot.",
            "additionalInformation": {
                "IDE": "Spyder IDE v5.1.5",
                "OperatingSystem": "Windows 10",
                "MatplotlibVersion": "3.4.3",
                "MatplotlibBackend": "Qt5Agg",
                "PythonVersion": "3.9.1",
                "InstallationMethod": "conda"
            }
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-22931",
        "structure_problem": {
            "problemSummary": "Regression in dashes due to #22569. Previously working plotting code fails to display a line and raises a ValueError.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot as plt",
                "Create a figure and axis using plt.subplots()",
                "Plot a line with dashes using ax.plot([0, 1], [0, 1], ls=(0, ()))",
                "Display the plot using plt.show()"
            ],
            "expectedResults": "A line should be displayed on the plot.",
            "actualResults": "No line is shown, and a ValueError is raised: 'At least one value in the dash list must be positive'.",
            "additionalInformation": {
                "OperatingSystem": "Ubuntu 22.04",
                "MatplotlibVersion": "96ddc6728ce09cb61f6b6c53714755fe0936b106",
                "MatplotlibBackend": "QtAgg (PyQt6)",
                "PythonVersion": "3.10.4",
                "InstallationMethod": "git checkout"
            }
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-23047",
        "structure_problem": {
            "problemSummary": "Gaps and overlapping areas between bins when using float16 data in histogram creation.",
            "stepsToReproduce": "1. Import numpy and matplotlib.pyplot.\n2. Generate float16 data using numpy.random.normal and clip it between 0 and 1.\n3. Create a histogram using plt.hist with the float16 data and specify the number of bins.\n4. Display the histogram using plt.show().",
            "expectedResults": "Histogram bins should be accurately calculated without gaps or overlaps.",
            "actualResults": "Gaps between certain bins and overlapping areas between neighboring bins are observed.",
            "additionalInformation": {
                "PossibleSolution": "Calculate the bins in float32 to avoid numerical errors.",
                "OperatingSystem": "Windows 10",
                "MatplotlibVersion": "3.4.3",
                "MatplotlibBackend": "TkAgg",
                "PythonVersion": "3.7.1",
                "InstallationMethod": "pip"
            }
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-23111",
        "structure_problem": {
            "problemSummary": "Imshow with all negative values leads to math domain errors.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot and numpy.",
                "Create a numpy array filled with identical negative values.",
                "Use plt.imshow to display the array.",
                "Hover the mouse over the displayed image."
            ],
            "expectedResults": "The value area should be displayed correctly.",
            "actualResults": "Hovering the mouse over the plot spews math domain errors into console and stops the value and coordinate under the mouse from being displayed in the top right.",
            "additionalInformation": {
                "OperatingSystem": "Windows 10 19044.1645",
                "MatplotlibVersion": "3.5.1",
                "MatplotlibBackend": "QtAgg",
                "PythonVersion": "Python 3.9.12",
                "InstallationMethod": "conda"
            }
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-23412",
        "structure_problem": {
            "problemSummary": "When setting the linestyle on a patch object using a dash tuple, the offset has no effect.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot as plt and matplotlib as mpl.",
                "Create a figure with a specified size.",
                "Get the current axes.",
                "Add a patch (Rectangle) with specified parameters including linestyle with an offset.",
                "Set the limits for the y and x axes.",
                "Display the plot."
            ],
            "expectedResults": "The patch edge lines should not overlap and should adhere to the specified offset.",
            "actualResults": "The patch edge lines overlap, not adhering to the offset.",
            "additionalInformation": {
                "OperatingSystem": "OS/X",
                "MatplotlibVersion": "3.3.4",
                "MatplotlibBackend": "MacOSX",
                "PythonVersion": "3.8.8",
                "InstallationMethod": "conda"
            }
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24088",
        "structure_problem": {
            "problemSummary": "ValueError: Unable to determine Axes to steal space for Colorbar when adding a colorbar to plt.hist() in matplotlib==3.6.0.",
            "stepsToReproduce": [
                "Import matplotlib.pyplot as plt and numpy as np.",
                "Generate random data using np.random.rand(100).",
                "Create a histogram using plt.hist().",
                "Assign colors to the histogram bars based on bin edges using a colormap.",
                "Attempt to add a colorbar using plt.colorbar()."
            ],
            "expectedResults": "The colorbar should be added to the histogram without raising an error.",
            "actualResults": "ValueError: Unable to determine Axes to steal space for Colorbar is raised.",
            "operatingSystem": "macOS 12.6",
            "matplotlibVersion": "3.6.0",
            "pythonVersion": "3.10",
            "installationMethod": "pip"
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24177",
        "structure_problem": {
            "problemSummary": "The histogram's density axis is not automatically adjusted to fit the whole histogram when using `histtype='step'` with `density=True`. Rescaling the data affects the density values, which is counterintuitive as it should only affect the x-axis values.",
            "stepsToReproduce": [
                "Generate some data using `numpy.random.randn(100000) * scale`.",
                "Create a figure with two subplots.",
                "Plot the histogram of the data in the first subplot using `histtype='bar'` and `density=True`.",
                "Plot the histogram of the same data in the second subplot using `histtype='step'` and `density=True`.",
                "Observe the differences in the density values between the two subplots."
            ],
            "expectedResults": "The density axis should be automatically adjusted to fit the whole histogram regardless of the `histtype` used.",
            "actualResults": "The density axis is not automatically adjusted when using `histtype='step'`, leading to different density values compared to `histtype='bar'`.",
            "additionalInformation": {
                "OperatingSystem": "OS/X",
                "MatplotlibVersion": "3.6.0",
                "PythonVersion": "3.10.4",
                "InstallationMethod": "pip"
            }
        }
    },
    {
        "instance_id": "matplotlib__matplotlib-24189",
        "structure_problem": {
            "problemSummary": "Error using width_ratios with nested mosaic in subplot_mosaic()",
            "stepsToReproduce": [
                "Import matplotlib.pyplot as plt",
                "Define mosaic as [['A', [['B'], ['C']]]]",
                "Call plt.subplot_mosaic(mosaic, width_ratios=[2, 1])"
            ],
            "expectedResults": "The subplot_mosaic function should create a nested mosaic layout with specified width ratios without raising an error.",
            "actualResults": "An error is raised: 'ValueError: Expected the given number of width ratios to match the number of columns of the grid'",
            "additionalInformation": {
                "OperatingSystem": "Windows 10",
                "MatplotlibVersion": "3.6.0",
                "MatplotlibBackend": "QtAgg",
                "PythonVersion": "3.10",
                "InstallationMethod": "conda"
            }
        }
    }
]